// This file is generated by rust-protobuf 2.1.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct AssistRequest {
    // message oneof groups
    pub field_type: ::std::option::Option<AssistRequest_oneof_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum AssistRequest_oneof_type {
    config(AssistConfig),
    audio_in(::std::vec::Vec<u8>),
}

impl AssistRequest {
    pub fn new() -> AssistRequest {
        ::std::default::Default::default()
    }

    // .google.assistant.embedded.v1alpha2.AssistConfig config = 1;

    pub fn clear_config(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_config(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(AssistRequest_oneof_type::config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: AssistConfig) {
        self.field_type = ::std::option::Option::Some(AssistRequest_oneof_type::config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_config(&mut self) -> &mut AssistConfig {
        if let ::std::option::Option::Some(AssistRequest_oneof_type::config(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(AssistRequest_oneof_type::config(AssistConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(AssistRequest_oneof_type::config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_config(&mut self) -> AssistConfig {
        if self.has_config() {
            match self.field_type.take() {
                ::std::option::Option::Some(AssistRequest_oneof_type::config(v)) => v,
                _ => panic!(),
            }
        } else {
            AssistConfig::new()
        }
    }

    pub fn get_config(&self) -> &AssistConfig {
        match self.field_type {
            ::std::option::Option::Some(AssistRequest_oneof_type::config(ref v)) => v,
            _ => AssistConfig::default_instance(),
        }
    }

    // bytes audio_in = 2;

    pub fn clear_audio_in(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_audio_in(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(AssistRequest_oneof_type::audio_in(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_audio_in(&mut self, v: ::std::vec::Vec<u8>) {
        self.field_type = ::std::option::Option::Some(AssistRequest_oneof_type::audio_in(v))
    }

    // Mutable pointer to the field.
    pub fn mut_audio_in(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(AssistRequest_oneof_type::audio_in(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(AssistRequest_oneof_type::audio_in(::std::vec::Vec::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(AssistRequest_oneof_type::audio_in(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_audio_in(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_audio_in() {
            match self.field_type.take() {
                ::std::option::Option::Some(AssistRequest_oneof_type::audio_in(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    pub fn get_audio_in(&self) -> &[u8] {
        match self.field_type {
            ::std::option::Option::Some(AssistRequest_oneof_type::audio_in(ref v)) => v,
            _ => &[],
        }
    }
}

impl ::protobuf::Message for AssistRequest {
    fn is_initialized(&self) -> bool {
        if let Some(AssistRequest_oneof_type::config(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(AssistRequest_oneof_type::config(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(AssistRequest_oneof_type::audio_in(is.read_bytes()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &AssistRequest_oneof_type::config(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &AssistRequest_oneof_type::audio_in(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &AssistRequest_oneof_type::config(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &AssistRequest_oneof_type::audio_in(ref v) => {
                    os.write_bytes(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AssistRequest {
        AssistRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AssistConfig>(
                    "config",
                    AssistRequest::has_config,
                    AssistRequest::get_config,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "audio_in",
                    AssistRequest::has_audio_in,
                    AssistRequest::get_audio_in,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AssistRequest>(
                    "AssistRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AssistRequest {
        static mut instance: ::protobuf::lazy::Lazy<AssistRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AssistRequest,
        };
        unsafe {
            instance.get(AssistRequest::new)
        }
    }
}

impl ::protobuf::Clear for AssistRequest {
    fn clear(&mut self) {
        self.clear_config();
        self.clear_audio_in();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AssistRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssistRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AssistResponse {
    // message fields
    pub event_type: AssistResponse_EventType,
    pub audio_out: ::protobuf::SingularPtrField<AudioOut>,
    pub screen_out: ::protobuf::SingularPtrField<ScreenOut>,
    pub device_action: ::protobuf::SingularPtrField<DeviceAction>,
    pub speech_results: ::protobuf::RepeatedField<SpeechRecognitionResult>,
    pub dialog_state_out: ::protobuf::SingularPtrField<DialogStateOut>,
    pub debug_info: ::protobuf::SingularPtrField<DebugInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl AssistResponse {
    pub fn new() -> AssistResponse {
        ::std::default::Default::default()
    }

    // .google.assistant.embedded.v1alpha2.AssistResponse.EventType event_type = 1;

    pub fn clear_event_type(&mut self) {
        self.event_type = AssistResponse_EventType::EVENT_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: AssistResponse_EventType) {
        self.event_type = v;
    }

    pub fn get_event_type(&self) -> AssistResponse_EventType {
        self.event_type
    }

    // .google.assistant.embedded.v1alpha2.AudioOut audio_out = 3;

    pub fn clear_audio_out(&mut self) {
        self.audio_out.clear();
    }

    pub fn has_audio_out(&self) -> bool {
        self.audio_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audio_out(&mut self, v: AudioOut) {
        self.audio_out = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_audio_out(&mut self) -> &mut AudioOut {
        if self.audio_out.is_none() {
            self.audio_out.set_default();
        }
        self.audio_out.as_mut().unwrap()
    }

    // Take field
    pub fn take_audio_out(&mut self) -> AudioOut {
        self.audio_out.take().unwrap_or_else(|| AudioOut::new())
    }

    pub fn get_audio_out(&self) -> &AudioOut {
        self.audio_out.as_ref().unwrap_or_else(|| AudioOut::default_instance())
    }

    // .google.assistant.embedded.v1alpha2.ScreenOut screen_out = 4;

    pub fn clear_screen_out(&mut self) {
        self.screen_out.clear();
    }

    pub fn has_screen_out(&self) -> bool {
        self.screen_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screen_out(&mut self, v: ScreenOut) {
        self.screen_out = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_screen_out(&mut self) -> &mut ScreenOut {
        if self.screen_out.is_none() {
            self.screen_out.set_default();
        }
        self.screen_out.as_mut().unwrap()
    }

    // Take field
    pub fn take_screen_out(&mut self) -> ScreenOut {
        self.screen_out.take().unwrap_or_else(|| ScreenOut::new())
    }

    pub fn get_screen_out(&self) -> &ScreenOut {
        self.screen_out.as_ref().unwrap_or_else(|| ScreenOut::default_instance())
    }

    // .google.assistant.embedded.v1alpha2.DeviceAction device_action = 6;

    pub fn clear_device_action(&mut self) {
        self.device_action.clear();
    }

    pub fn has_device_action(&self) -> bool {
        self.device_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_action(&mut self, v: DeviceAction) {
        self.device_action = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_action(&mut self) -> &mut DeviceAction {
        if self.device_action.is_none() {
            self.device_action.set_default();
        }
        self.device_action.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_action(&mut self) -> DeviceAction {
        self.device_action.take().unwrap_or_else(|| DeviceAction::new())
    }

    pub fn get_device_action(&self) -> &DeviceAction {
        self.device_action.as_ref().unwrap_or_else(|| DeviceAction::default_instance())
    }

    // repeated .google.assistant.embedded.v1alpha2.SpeechRecognitionResult speech_results = 2;

    pub fn clear_speech_results(&mut self) {
        self.speech_results.clear();
    }

    // Param is passed by value, moved
    pub fn set_speech_results(&mut self, v: ::protobuf::RepeatedField<SpeechRecognitionResult>) {
        self.speech_results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_speech_results(&mut self) -> &mut ::protobuf::RepeatedField<SpeechRecognitionResult> {
        &mut self.speech_results
    }

    // Take field
    pub fn take_speech_results(&mut self) -> ::protobuf::RepeatedField<SpeechRecognitionResult> {
        ::std::mem::replace(&mut self.speech_results, ::protobuf::RepeatedField::new())
    }

    pub fn get_speech_results(&self) -> &[SpeechRecognitionResult] {
        &self.speech_results
    }

    // .google.assistant.embedded.v1alpha2.DialogStateOut dialog_state_out = 5;

    pub fn clear_dialog_state_out(&mut self) {
        self.dialog_state_out.clear();
    }

    pub fn has_dialog_state_out(&self) -> bool {
        self.dialog_state_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dialog_state_out(&mut self, v: DialogStateOut) {
        self.dialog_state_out = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dialog_state_out(&mut self) -> &mut DialogStateOut {
        if self.dialog_state_out.is_none() {
            self.dialog_state_out.set_default();
        }
        self.dialog_state_out.as_mut().unwrap()
    }

    // Take field
    pub fn take_dialog_state_out(&mut self) -> DialogStateOut {
        self.dialog_state_out.take().unwrap_or_else(|| DialogStateOut::new())
    }

    pub fn get_dialog_state_out(&self) -> &DialogStateOut {
        self.dialog_state_out.as_ref().unwrap_or_else(|| DialogStateOut::default_instance())
    }

    // .google.assistant.embedded.v1alpha2.DebugInfo debug_info = 8;

    pub fn clear_debug_info(&mut self) {
        self.debug_info.clear();
    }

    pub fn has_debug_info(&self) -> bool {
        self.debug_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_info(&mut self, v: DebugInfo) {
        self.debug_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug_info(&mut self) -> &mut DebugInfo {
        if self.debug_info.is_none() {
            self.debug_info.set_default();
        }
        self.debug_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug_info(&mut self) -> DebugInfo {
        self.debug_info.take().unwrap_or_else(|| DebugInfo::new())
    }

    pub fn get_debug_info(&self) -> &DebugInfo {
        self.debug_info.as_ref().unwrap_or_else(|| DebugInfo::default_instance())
    }
}

impl ::protobuf::Message for AssistResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.audio_out {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.screen_out {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.device_action {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.speech_results {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dialog_state_out {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.debug_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.event_type, 1, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.audio_out)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.screen_out)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.device_action)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.speech_results)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dialog_state_out)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.debug_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.event_type != AssistResponse_EventType::EVENT_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.event_type);
        }
        if let Some(ref v) = self.audio_out.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.screen_out.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.device_action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.speech_results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.dialog_state_out.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.debug_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.event_type != AssistResponse_EventType::EVENT_TYPE_UNSPECIFIED {
            os.write_enum(1, self.event_type.value())?;
        }
        if let Some(ref v) = self.audio_out.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.screen_out.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.device_action.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.speech_results {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.dialog_state_out.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.debug_info.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AssistResponse {
        AssistResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AssistResponse_EventType>>(
                    "event_type",
                    |m: &AssistResponse| { &m.event_type },
                    |m: &mut AssistResponse| { &mut m.event_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AudioOut>>(
                    "audio_out",
                    |m: &AssistResponse| { &m.audio_out },
                    |m: &mut AssistResponse| { &mut m.audio_out },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ScreenOut>>(
                    "screen_out",
                    |m: &AssistResponse| { &m.screen_out },
                    |m: &mut AssistResponse| { &mut m.screen_out },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceAction>>(
                    "device_action",
                    |m: &AssistResponse| { &m.device_action },
                    |m: &mut AssistResponse| { &mut m.device_action },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SpeechRecognitionResult>>(
                    "speech_results",
                    |m: &AssistResponse| { &m.speech_results },
                    |m: &mut AssistResponse| { &mut m.speech_results },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DialogStateOut>>(
                    "dialog_state_out",
                    |m: &AssistResponse| { &m.dialog_state_out },
                    |m: &mut AssistResponse| { &mut m.dialog_state_out },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DebugInfo>>(
                    "debug_info",
                    |m: &AssistResponse| { &m.debug_info },
                    |m: &mut AssistResponse| { &mut m.debug_info },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AssistResponse>(
                    "AssistResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AssistResponse {
        static mut instance: ::protobuf::lazy::Lazy<AssistResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AssistResponse,
        };
        unsafe {
            instance.get(AssistResponse::new)
        }
    }
}

impl ::protobuf::Clear for AssistResponse {
    fn clear(&mut self) {
        self.clear_event_type();
        self.clear_audio_out();
        self.clear_screen_out();
        self.clear_device_action();
        self.clear_speech_results();
        self.clear_dialog_state_out();
        self.clear_debug_info();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AssistResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssistResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AssistResponse_EventType {
    EVENT_TYPE_UNSPECIFIED = 0,
    END_OF_UTTERANCE = 1,
}

impl ::protobuf::ProtobufEnum for AssistResponse_EventType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AssistResponse_EventType> {
        match value {
            0 => ::std::option::Option::Some(AssistResponse_EventType::EVENT_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(AssistResponse_EventType::END_OF_UTTERANCE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AssistResponse_EventType] = &[
            AssistResponse_EventType::EVENT_TYPE_UNSPECIFIED,
            AssistResponse_EventType::END_OF_UTTERANCE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AssistResponse_EventType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AssistResponse_EventType {
}

impl ::std::default::Default for AssistResponse_EventType {
    fn default() -> Self {
        AssistResponse_EventType::EVENT_TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for AssistResponse_EventType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DebugInfo {
    // message fields
    pub aog_agent_to_assistant_json: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DebugInfo {
    pub fn new() -> DebugInfo {
        ::std::default::Default::default()
    }

    // string aog_agent_to_assistant_json = 1;

    pub fn clear_aog_agent_to_assistant_json(&mut self) {
        self.aog_agent_to_assistant_json.clear();
    }

    // Param is passed by value, moved
    pub fn set_aog_agent_to_assistant_json(&mut self, v: ::std::string::String) {
        self.aog_agent_to_assistant_json = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aog_agent_to_assistant_json(&mut self) -> &mut ::std::string::String {
        &mut self.aog_agent_to_assistant_json
    }

    // Take field
    pub fn take_aog_agent_to_assistant_json(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.aog_agent_to_assistant_json, ::std::string::String::new())
    }

    pub fn get_aog_agent_to_assistant_json(&self) -> &str {
        &self.aog_agent_to_assistant_json
    }
}

impl ::protobuf::Message for DebugInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.aog_agent_to_assistant_json)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.aog_agent_to_assistant_json.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.aog_agent_to_assistant_json);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.aog_agent_to_assistant_json.is_empty() {
            os.write_string(1, &self.aog_agent_to_assistant_json)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugInfo {
        DebugInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "aog_agent_to_assistant_json",
                    |m: &DebugInfo| { &m.aog_agent_to_assistant_json },
                    |m: &mut DebugInfo| { &mut m.aog_agent_to_assistant_json },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DebugInfo>(
                    "DebugInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DebugInfo {
        static mut instance: ::protobuf::lazy::Lazy<DebugInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DebugInfo,
        };
        unsafe {
            instance.get(DebugInfo::new)
        }
    }
}

impl ::protobuf::Clear for DebugInfo {
    fn clear(&mut self) {
        self.clear_aog_agent_to_assistant_json();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AssistConfig {
    // message fields
    pub audio_out_config: ::protobuf::SingularPtrField<AudioOutConfig>,
    pub screen_out_config: ::protobuf::SingularPtrField<ScreenOutConfig>,
    pub dialog_state_in: ::protobuf::SingularPtrField<DialogStateIn>,
    pub device_config: ::protobuf::SingularPtrField<DeviceConfig>,
    pub debug_config: ::protobuf::SingularPtrField<DebugConfig>,
    // message oneof groups
    pub field_type: ::std::option::Option<AssistConfig_oneof_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum AssistConfig_oneof_type {
    audio_in_config(AudioInConfig),
    text_query(::std::string::String),
}

impl AssistConfig {
    pub fn new() -> AssistConfig {
        ::std::default::Default::default()
    }

    // .google.assistant.embedded.v1alpha2.AudioInConfig audio_in_config = 1;

    pub fn clear_audio_in_config(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_audio_in_config(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(AssistConfig_oneof_type::audio_in_config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_audio_in_config(&mut self, v: AudioInConfig) {
        self.field_type = ::std::option::Option::Some(AssistConfig_oneof_type::audio_in_config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_audio_in_config(&mut self) -> &mut AudioInConfig {
        if let ::std::option::Option::Some(AssistConfig_oneof_type::audio_in_config(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(AssistConfig_oneof_type::audio_in_config(AudioInConfig::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(AssistConfig_oneof_type::audio_in_config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_audio_in_config(&mut self) -> AudioInConfig {
        if self.has_audio_in_config() {
            match self.field_type.take() {
                ::std::option::Option::Some(AssistConfig_oneof_type::audio_in_config(v)) => v,
                _ => panic!(),
            }
        } else {
            AudioInConfig::new()
        }
    }

    pub fn get_audio_in_config(&self) -> &AudioInConfig {
        match self.field_type {
            ::std::option::Option::Some(AssistConfig_oneof_type::audio_in_config(ref v)) => v,
            _ => AudioInConfig::default_instance(),
        }
    }

    // string text_query = 6;

    pub fn clear_text_query(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_text_query(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(AssistConfig_oneof_type::text_query(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_text_query(&mut self, v: ::std::string::String) {
        self.field_type = ::std::option::Option::Some(AssistConfig_oneof_type::text_query(v))
    }

    // Mutable pointer to the field.
    pub fn mut_text_query(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(AssistConfig_oneof_type::text_query(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(AssistConfig_oneof_type::text_query(::std::string::String::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(AssistConfig_oneof_type::text_query(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_text_query(&mut self) -> ::std::string::String {
        if self.has_text_query() {
            match self.field_type.take() {
                ::std::option::Option::Some(AssistConfig_oneof_type::text_query(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_text_query(&self) -> &str {
        match self.field_type {
            ::std::option::Option::Some(AssistConfig_oneof_type::text_query(ref v)) => v,
            _ => "",
        }
    }

    // .google.assistant.embedded.v1alpha2.AudioOutConfig audio_out_config = 2;

    pub fn clear_audio_out_config(&mut self) {
        self.audio_out_config.clear();
    }

    pub fn has_audio_out_config(&self) -> bool {
        self.audio_out_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audio_out_config(&mut self, v: AudioOutConfig) {
        self.audio_out_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_audio_out_config(&mut self) -> &mut AudioOutConfig {
        if self.audio_out_config.is_none() {
            self.audio_out_config.set_default();
        }
        self.audio_out_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_audio_out_config(&mut self) -> AudioOutConfig {
        self.audio_out_config.take().unwrap_or_else(|| AudioOutConfig::new())
    }

    pub fn get_audio_out_config(&self) -> &AudioOutConfig {
        self.audio_out_config.as_ref().unwrap_or_else(|| AudioOutConfig::default_instance())
    }

    // .google.assistant.embedded.v1alpha2.ScreenOutConfig screen_out_config = 8;

    pub fn clear_screen_out_config(&mut self) {
        self.screen_out_config.clear();
    }

    pub fn has_screen_out_config(&self) -> bool {
        self.screen_out_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screen_out_config(&mut self, v: ScreenOutConfig) {
        self.screen_out_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_screen_out_config(&mut self) -> &mut ScreenOutConfig {
        if self.screen_out_config.is_none() {
            self.screen_out_config.set_default();
        }
        self.screen_out_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_screen_out_config(&mut self) -> ScreenOutConfig {
        self.screen_out_config.take().unwrap_or_else(|| ScreenOutConfig::new())
    }

    pub fn get_screen_out_config(&self) -> &ScreenOutConfig {
        self.screen_out_config.as_ref().unwrap_or_else(|| ScreenOutConfig::default_instance())
    }

    // .google.assistant.embedded.v1alpha2.DialogStateIn dialog_state_in = 3;

    pub fn clear_dialog_state_in(&mut self) {
        self.dialog_state_in.clear();
    }

    pub fn has_dialog_state_in(&self) -> bool {
        self.dialog_state_in.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dialog_state_in(&mut self, v: DialogStateIn) {
        self.dialog_state_in = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dialog_state_in(&mut self) -> &mut DialogStateIn {
        if self.dialog_state_in.is_none() {
            self.dialog_state_in.set_default();
        }
        self.dialog_state_in.as_mut().unwrap()
    }

    // Take field
    pub fn take_dialog_state_in(&mut self) -> DialogStateIn {
        self.dialog_state_in.take().unwrap_or_else(|| DialogStateIn::new())
    }

    pub fn get_dialog_state_in(&self) -> &DialogStateIn {
        self.dialog_state_in.as_ref().unwrap_or_else(|| DialogStateIn::default_instance())
    }

    // .google.assistant.embedded.v1alpha2.DeviceConfig device_config = 4;

    pub fn clear_device_config(&mut self) {
        self.device_config.clear();
    }

    pub fn has_device_config(&self) -> bool {
        self.device_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_config(&mut self, v: DeviceConfig) {
        self.device_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_config(&mut self) -> &mut DeviceConfig {
        if self.device_config.is_none() {
            self.device_config.set_default();
        }
        self.device_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_config(&mut self) -> DeviceConfig {
        self.device_config.take().unwrap_or_else(|| DeviceConfig::new())
    }

    pub fn get_device_config(&self) -> &DeviceConfig {
        self.device_config.as_ref().unwrap_or_else(|| DeviceConfig::default_instance())
    }

    // .google.assistant.embedded.v1alpha2.DebugConfig debug_config = 5;

    pub fn clear_debug_config(&mut self) {
        self.debug_config.clear();
    }

    pub fn has_debug_config(&self) -> bool {
        self.debug_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_config(&mut self, v: DebugConfig) {
        self.debug_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug_config(&mut self) -> &mut DebugConfig {
        if self.debug_config.is_none() {
            self.debug_config.set_default();
        }
        self.debug_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug_config(&mut self) -> DebugConfig {
        self.debug_config.take().unwrap_or_else(|| DebugConfig::new())
    }

    pub fn get_debug_config(&self) -> &DebugConfig {
        self.debug_config.as_ref().unwrap_or_else(|| DebugConfig::default_instance())
    }
}

impl ::protobuf::Message for AssistConfig {
    fn is_initialized(&self) -> bool {
        if let Some(AssistConfig_oneof_type::audio_in_config(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.audio_out_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.screen_out_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dialog_state_in {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.device_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.debug_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(AssistConfig_oneof_type::audio_in_config(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(AssistConfig_oneof_type::text_query(is.read_string()?));
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.audio_out_config)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.screen_out_config)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dialog_state_in)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.device_config)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.debug_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.audio_out_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.screen_out_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dialog_state_in.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.device_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.debug_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &AssistConfig_oneof_type::audio_in_config(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &AssistConfig_oneof_type::text_query(ref v) => {
                    my_size += ::protobuf::rt::string_size(6, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.audio_out_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.screen_out_config.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dialog_state_in.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.device_config.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.debug_config.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &AssistConfig_oneof_type::audio_in_config(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &AssistConfig_oneof_type::text_query(ref v) => {
                    os.write_string(6, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AssistConfig {
        AssistConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AudioInConfig>(
                    "audio_in_config",
                    AssistConfig::has_audio_in_config,
                    AssistConfig::get_audio_in_config,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "text_query",
                    AssistConfig::has_text_query,
                    AssistConfig::get_text_query,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AudioOutConfig>>(
                    "audio_out_config",
                    |m: &AssistConfig| { &m.audio_out_config },
                    |m: &mut AssistConfig| { &mut m.audio_out_config },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ScreenOutConfig>>(
                    "screen_out_config",
                    |m: &AssistConfig| { &m.screen_out_config },
                    |m: &mut AssistConfig| { &mut m.screen_out_config },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DialogStateIn>>(
                    "dialog_state_in",
                    |m: &AssistConfig| { &m.dialog_state_in },
                    |m: &mut AssistConfig| { &mut m.dialog_state_in },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceConfig>>(
                    "device_config",
                    |m: &AssistConfig| { &m.device_config },
                    |m: &mut AssistConfig| { &mut m.device_config },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DebugConfig>>(
                    "debug_config",
                    |m: &AssistConfig| { &m.debug_config },
                    |m: &mut AssistConfig| { &mut m.debug_config },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AssistConfig>(
                    "AssistConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AssistConfig {
        static mut instance: ::protobuf::lazy::Lazy<AssistConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AssistConfig,
        };
        unsafe {
            instance.get(AssistConfig::new)
        }
    }
}

impl ::protobuf::Clear for AssistConfig {
    fn clear(&mut self) {
        self.clear_audio_in_config();
        self.clear_text_query();
        self.clear_audio_out_config();
        self.clear_screen_out_config();
        self.clear_dialog_state_in();
        self.clear_device_config();
        self.clear_debug_config();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AssistConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssistConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AudioInConfig {
    // message fields
    pub encoding: AudioInConfig_Encoding,
    pub sample_rate_hertz: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl AudioInConfig {
    pub fn new() -> AudioInConfig {
        ::std::default::Default::default()
    }

    // .google.assistant.embedded.v1alpha2.AudioInConfig.Encoding encoding = 1;

    pub fn clear_encoding(&mut self) {
        self.encoding = AudioInConfig_Encoding::ENCODING_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_encoding(&mut self, v: AudioInConfig_Encoding) {
        self.encoding = v;
    }

    pub fn get_encoding(&self) -> AudioInConfig_Encoding {
        self.encoding
    }

    // int32 sample_rate_hertz = 2;

    pub fn clear_sample_rate_hertz(&mut self) {
        self.sample_rate_hertz = 0;
    }

    // Param is passed by value, moved
    pub fn set_sample_rate_hertz(&mut self, v: i32) {
        self.sample_rate_hertz = v;
    }

    pub fn get_sample_rate_hertz(&self) -> i32 {
        self.sample_rate_hertz
    }
}

impl ::protobuf::Message for AudioInConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.encoding, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sample_rate_hertz = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.encoding != AudioInConfig_Encoding::ENCODING_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.encoding);
        }
        if self.sample_rate_hertz != 0 {
            my_size += ::protobuf::rt::value_size(2, self.sample_rate_hertz, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.encoding != AudioInConfig_Encoding::ENCODING_UNSPECIFIED {
            os.write_enum(1, self.encoding.value())?;
        }
        if self.sample_rate_hertz != 0 {
            os.write_int32(2, self.sample_rate_hertz)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AudioInConfig {
        AudioInConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AudioInConfig_Encoding>>(
                    "encoding",
                    |m: &AudioInConfig| { &m.encoding },
                    |m: &mut AudioInConfig| { &mut m.encoding },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "sample_rate_hertz",
                    |m: &AudioInConfig| { &m.sample_rate_hertz },
                    |m: &mut AudioInConfig| { &mut m.sample_rate_hertz },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AudioInConfig>(
                    "AudioInConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AudioInConfig {
        static mut instance: ::protobuf::lazy::Lazy<AudioInConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AudioInConfig,
        };
        unsafe {
            instance.get(AudioInConfig::new)
        }
    }
}

impl ::protobuf::Clear for AudioInConfig {
    fn clear(&mut self) {
        self.clear_encoding();
        self.clear_sample_rate_hertz();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AudioInConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AudioInConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AudioInConfig_Encoding {
    ENCODING_UNSPECIFIED = 0,
    LINEAR16 = 1,
    FLAC = 2,
}

impl ::protobuf::ProtobufEnum for AudioInConfig_Encoding {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AudioInConfig_Encoding> {
        match value {
            0 => ::std::option::Option::Some(AudioInConfig_Encoding::ENCODING_UNSPECIFIED),
            1 => ::std::option::Option::Some(AudioInConfig_Encoding::LINEAR16),
            2 => ::std::option::Option::Some(AudioInConfig_Encoding::FLAC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AudioInConfig_Encoding] = &[
            AudioInConfig_Encoding::ENCODING_UNSPECIFIED,
            AudioInConfig_Encoding::LINEAR16,
            AudioInConfig_Encoding::FLAC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AudioInConfig_Encoding", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AudioInConfig_Encoding {
}

impl ::std::default::Default for AudioInConfig_Encoding {
    fn default() -> Self {
        AudioInConfig_Encoding::ENCODING_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for AudioInConfig_Encoding {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AudioOutConfig {
    // message fields
    pub encoding: AudioOutConfig_Encoding,
    pub sample_rate_hertz: i32,
    pub volume_percentage: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl AudioOutConfig {
    pub fn new() -> AudioOutConfig {
        ::std::default::Default::default()
    }

    // .google.assistant.embedded.v1alpha2.AudioOutConfig.Encoding encoding = 1;

    pub fn clear_encoding(&mut self) {
        self.encoding = AudioOutConfig_Encoding::ENCODING_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_encoding(&mut self, v: AudioOutConfig_Encoding) {
        self.encoding = v;
    }

    pub fn get_encoding(&self) -> AudioOutConfig_Encoding {
        self.encoding
    }

    // int32 sample_rate_hertz = 2;

    pub fn clear_sample_rate_hertz(&mut self) {
        self.sample_rate_hertz = 0;
    }

    // Param is passed by value, moved
    pub fn set_sample_rate_hertz(&mut self, v: i32) {
        self.sample_rate_hertz = v;
    }

    pub fn get_sample_rate_hertz(&self) -> i32 {
        self.sample_rate_hertz
    }

    // int32 volume_percentage = 3;

    pub fn clear_volume_percentage(&mut self) {
        self.volume_percentage = 0;
    }

    // Param is passed by value, moved
    pub fn set_volume_percentage(&mut self, v: i32) {
        self.volume_percentage = v;
    }

    pub fn get_volume_percentage(&self) -> i32 {
        self.volume_percentage
    }
}

impl ::protobuf::Message for AudioOutConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.encoding, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sample_rate_hertz = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.volume_percentage = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.encoding != AudioOutConfig_Encoding::ENCODING_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.encoding);
        }
        if self.sample_rate_hertz != 0 {
            my_size += ::protobuf::rt::value_size(2, self.sample_rate_hertz, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.volume_percentage != 0 {
            my_size += ::protobuf::rt::value_size(3, self.volume_percentage, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.encoding != AudioOutConfig_Encoding::ENCODING_UNSPECIFIED {
            os.write_enum(1, self.encoding.value())?;
        }
        if self.sample_rate_hertz != 0 {
            os.write_int32(2, self.sample_rate_hertz)?;
        }
        if self.volume_percentage != 0 {
            os.write_int32(3, self.volume_percentage)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AudioOutConfig {
        AudioOutConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AudioOutConfig_Encoding>>(
                    "encoding",
                    |m: &AudioOutConfig| { &m.encoding },
                    |m: &mut AudioOutConfig| { &mut m.encoding },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "sample_rate_hertz",
                    |m: &AudioOutConfig| { &m.sample_rate_hertz },
                    |m: &mut AudioOutConfig| { &mut m.sample_rate_hertz },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "volume_percentage",
                    |m: &AudioOutConfig| { &m.volume_percentage },
                    |m: &mut AudioOutConfig| { &mut m.volume_percentage },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AudioOutConfig>(
                    "AudioOutConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AudioOutConfig {
        static mut instance: ::protobuf::lazy::Lazy<AudioOutConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AudioOutConfig,
        };
        unsafe {
            instance.get(AudioOutConfig::new)
        }
    }
}

impl ::protobuf::Clear for AudioOutConfig {
    fn clear(&mut self) {
        self.clear_encoding();
        self.clear_sample_rate_hertz();
        self.clear_volume_percentage();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AudioOutConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AudioOutConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AudioOutConfig_Encoding {
    ENCODING_UNSPECIFIED = 0,
    LINEAR16 = 1,
    MP3 = 2,
    OPUS_IN_OGG = 3,
}

impl ::protobuf::ProtobufEnum for AudioOutConfig_Encoding {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AudioOutConfig_Encoding> {
        match value {
            0 => ::std::option::Option::Some(AudioOutConfig_Encoding::ENCODING_UNSPECIFIED),
            1 => ::std::option::Option::Some(AudioOutConfig_Encoding::LINEAR16),
            2 => ::std::option::Option::Some(AudioOutConfig_Encoding::MP3),
            3 => ::std::option::Option::Some(AudioOutConfig_Encoding::OPUS_IN_OGG),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AudioOutConfig_Encoding] = &[
            AudioOutConfig_Encoding::ENCODING_UNSPECIFIED,
            AudioOutConfig_Encoding::LINEAR16,
            AudioOutConfig_Encoding::MP3,
            AudioOutConfig_Encoding::OPUS_IN_OGG,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AudioOutConfig_Encoding", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AudioOutConfig_Encoding {
}

impl ::std::default::Default for AudioOutConfig_Encoding {
    fn default() -> Self {
        AudioOutConfig_Encoding::ENCODING_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for AudioOutConfig_Encoding {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScreenOutConfig {
    // message fields
    pub screen_mode: ScreenOutConfig_ScreenMode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ScreenOutConfig {
    pub fn new() -> ScreenOutConfig {
        ::std::default::Default::default()
    }

    // .google.assistant.embedded.v1alpha2.ScreenOutConfig.ScreenMode screen_mode = 1;

    pub fn clear_screen_mode(&mut self) {
        self.screen_mode = ScreenOutConfig_ScreenMode::SCREEN_MODE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_screen_mode(&mut self, v: ScreenOutConfig_ScreenMode) {
        self.screen_mode = v;
    }

    pub fn get_screen_mode(&self) -> ScreenOutConfig_ScreenMode {
        self.screen_mode
    }
}

impl ::protobuf::Message for ScreenOutConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.screen_mode, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.screen_mode != ScreenOutConfig_ScreenMode::SCREEN_MODE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.screen_mode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.screen_mode != ScreenOutConfig_ScreenMode::SCREEN_MODE_UNSPECIFIED {
            os.write_enum(1, self.screen_mode.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScreenOutConfig {
        ScreenOutConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ScreenOutConfig_ScreenMode>>(
                    "screen_mode",
                    |m: &ScreenOutConfig| { &m.screen_mode },
                    |m: &mut ScreenOutConfig| { &mut m.screen_mode },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ScreenOutConfig>(
                    "ScreenOutConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ScreenOutConfig {
        static mut instance: ::protobuf::lazy::Lazy<ScreenOutConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ScreenOutConfig,
        };
        unsafe {
            instance.get(ScreenOutConfig::new)
        }
    }
}

impl ::protobuf::Clear for ScreenOutConfig {
    fn clear(&mut self) {
        self.clear_screen_mode();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScreenOutConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScreenOutConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ScreenOutConfig_ScreenMode {
    SCREEN_MODE_UNSPECIFIED = 0,
    OFF = 1,
    PLAYING = 3,
}

impl ::protobuf::ProtobufEnum for ScreenOutConfig_ScreenMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ScreenOutConfig_ScreenMode> {
        match value {
            0 => ::std::option::Option::Some(ScreenOutConfig_ScreenMode::SCREEN_MODE_UNSPECIFIED),
            1 => ::std::option::Option::Some(ScreenOutConfig_ScreenMode::OFF),
            3 => ::std::option::Option::Some(ScreenOutConfig_ScreenMode::PLAYING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ScreenOutConfig_ScreenMode] = &[
            ScreenOutConfig_ScreenMode::SCREEN_MODE_UNSPECIFIED,
            ScreenOutConfig_ScreenMode::OFF,
            ScreenOutConfig_ScreenMode::PLAYING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ScreenOutConfig_ScreenMode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ScreenOutConfig_ScreenMode {
}

impl ::std::default::Default for ScreenOutConfig_ScreenMode {
    fn default() -> Self {
        ScreenOutConfig_ScreenMode::SCREEN_MODE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for ScreenOutConfig_ScreenMode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DialogStateIn {
    // message fields
    pub conversation_state: ::std::vec::Vec<u8>,
    pub language_code: ::std::string::String,
    pub device_location: ::protobuf::SingularPtrField<DeviceLocation>,
    pub is_new_conversation: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DialogStateIn {
    pub fn new() -> DialogStateIn {
        ::std::default::Default::default()
    }

    // bytes conversation_state = 1;

    pub fn clear_conversation_state(&mut self) {
        self.conversation_state.clear();
    }

    // Param is passed by value, moved
    pub fn set_conversation_state(&mut self, v: ::std::vec::Vec<u8>) {
        self.conversation_state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conversation_state(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.conversation_state
    }

    // Take field
    pub fn take_conversation_state(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.conversation_state, ::std::vec::Vec::new())
    }

    pub fn get_conversation_state(&self) -> &[u8] {
        &self.conversation_state
    }

    // string language_code = 2;

    pub fn clear_language_code(&mut self) {
        self.language_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_language_code(&mut self, v: ::std::string::String) {
        self.language_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language_code(&mut self) -> &mut ::std::string::String {
        &mut self.language_code
    }

    // Take field
    pub fn take_language_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.language_code, ::std::string::String::new())
    }

    pub fn get_language_code(&self) -> &str {
        &self.language_code
    }

    // .google.assistant.embedded.v1alpha2.DeviceLocation device_location = 5;

    pub fn clear_device_location(&mut self) {
        self.device_location.clear();
    }

    pub fn has_device_location(&self) -> bool {
        self.device_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_location(&mut self, v: DeviceLocation) {
        self.device_location = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_location(&mut self) -> &mut DeviceLocation {
        if self.device_location.is_none() {
            self.device_location.set_default();
        }
        self.device_location.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_location(&mut self) -> DeviceLocation {
        self.device_location.take().unwrap_or_else(|| DeviceLocation::new())
    }

    pub fn get_device_location(&self) -> &DeviceLocation {
        self.device_location.as_ref().unwrap_or_else(|| DeviceLocation::default_instance())
    }

    // bool is_new_conversation = 7;

    pub fn clear_is_new_conversation(&mut self) {
        self.is_new_conversation = false;
    }

    // Param is passed by value, moved
    pub fn set_is_new_conversation(&mut self, v: bool) {
        self.is_new_conversation = v;
    }

    pub fn get_is_new_conversation(&self) -> bool {
        self.is_new_conversation
    }
}

impl ::protobuf::Message for DialogStateIn {
    fn is_initialized(&self) -> bool {
        for v in &self.device_location {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.conversation_state)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.language_code)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.device_location)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_new_conversation = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.conversation_state.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.conversation_state);
        }
        if !self.language_code.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.language_code);
        }
        if let Some(ref v) = self.device_location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.is_new_conversation != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.conversation_state.is_empty() {
            os.write_bytes(1, &self.conversation_state)?;
        }
        if !self.language_code.is_empty() {
            os.write_string(2, &self.language_code)?;
        }
        if let Some(ref v) = self.device_location.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.is_new_conversation != false {
            os.write_bool(7, self.is_new_conversation)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DialogStateIn {
        DialogStateIn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "conversation_state",
                    |m: &DialogStateIn| { &m.conversation_state },
                    |m: &mut DialogStateIn| { &mut m.conversation_state },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "language_code",
                    |m: &DialogStateIn| { &m.language_code },
                    |m: &mut DialogStateIn| { &mut m.language_code },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceLocation>>(
                    "device_location",
                    |m: &DialogStateIn| { &m.device_location },
                    |m: &mut DialogStateIn| { &mut m.device_location },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_new_conversation",
                    |m: &DialogStateIn| { &m.is_new_conversation },
                    |m: &mut DialogStateIn| { &mut m.is_new_conversation },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DialogStateIn>(
                    "DialogStateIn",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DialogStateIn {
        static mut instance: ::protobuf::lazy::Lazy<DialogStateIn> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DialogStateIn,
        };
        unsafe {
            instance.get(DialogStateIn::new)
        }
    }
}

impl ::protobuf::Clear for DialogStateIn {
    fn clear(&mut self) {
        self.clear_conversation_state();
        self.clear_language_code();
        self.clear_device_location();
        self.clear_is_new_conversation();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DialogStateIn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DialogStateIn {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceConfig {
    // message fields
    pub device_id: ::std::string::String,
    pub device_model_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DeviceConfig {
    pub fn new() -> DeviceConfig {
        ::std::default::Default::default()
    }

    // string device_id = 1;

    pub fn clear_device_id(&mut self) {
        self.device_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: ::std::string::String) {
        self.device_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_id(&mut self) -> &mut ::std::string::String {
        &mut self.device_id
    }

    // Take field
    pub fn take_device_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_id, ::std::string::String::new())
    }

    pub fn get_device_id(&self) -> &str {
        &self.device_id
    }

    // string device_model_id = 3;

    pub fn clear_device_model_id(&mut self) {
        self.device_model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_model_id(&mut self, v: ::std::string::String) {
        self.device_model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.device_model_id
    }

    // Take field
    pub fn take_device_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_model_id, ::std::string::String::new())
    }

    pub fn get_device_model_id(&self) -> &str {
        &self.device_model_id
    }
}

impl ::protobuf::Message for DeviceConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_model_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.device_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.device_id);
        }
        if !self.device_model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.device_model_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.device_id.is_empty() {
            os.write_string(1, &self.device_id)?;
        }
        if !self.device_model_id.is_empty() {
            os.write_string(3, &self.device_model_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceConfig {
        DeviceConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "device_id",
                    |m: &DeviceConfig| { &m.device_id },
                    |m: &mut DeviceConfig| { &mut m.device_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "device_model_id",
                    |m: &DeviceConfig| { &m.device_model_id },
                    |m: &mut DeviceConfig| { &mut m.device_model_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceConfig>(
                    "DeviceConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceConfig {
        static mut instance: ::protobuf::lazy::Lazy<DeviceConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceConfig,
        };
        unsafe {
            instance.get(DeviceConfig::new)
        }
    }
}

impl ::protobuf::Clear for DeviceConfig {
    fn clear(&mut self) {
        self.clear_device_id();
        self.clear_device_model_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AudioOut {
    // message fields
    pub audio_data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl AudioOut {
    pub fn new() -> AudioOut {
        ::std::default::Default::default()
    }

    // bytes audio_data = 1;

    pub fn clear_audio_data(&mut self) {
        self.audio_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_audio_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.audio_data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_audio_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.audio_data
    }

    // Take field
    pub fn take_audio_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.audio_data, ::std::vec::Vec::new())
    }

    pub fn get_audio_data(&self) -> &[u8] {
        &self.audio_data
    }
}

impl ::protobuf::Message for AudioOut {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.audio_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.audio_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.audio_data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.audio_data.is_empty() {
            os.write_bytes(1, &self.audio_data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AudioOut {
        AudioOut::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "audio_data",
                    |m: &AudioOut| { &m.audio_data },
                    |m: &mut AudioOut| { &mut m.audio_data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AudioOut>(
                    "AudioOut",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AudioOut {
        static mut instance: ::protobuf::lazy::Lazy<AudioOut> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AudioOut,
        };
        unsafe {
            instance.get(AudioOut::new)
        }
    }
}

impl ::protobuf::Clear for AudioOut {
    fn clear(&mut self) {
        self.clear_audio_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AudioOut {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AudioOut {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScreenOut {
    // message fields
    pub format: ScreenOut_Format,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ScreenOut {
    pub fn new() -> ScreenOut {
        ::std::default::Default::default()
    }

    // .google.assistant.embedded.v1alpha2.ScreenOut.Format format = 1;

    pub fn clear_format(&mut self) {
        self.format = ScreenOut_Format::FORMAT_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: ScreenOut_Format) {
        self.format = v;
    }

    pub fn get_format(&self) -> ScreenOut_Format {
        self.format
    }

    // bytes data = 2;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
}

impl ::protobuf::Message for ScreenOut {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.format, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.format != ScreenOut_Format::FORMAT_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.format);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.format != ScreenOut_Format::FORMAT_UNSPECIFIED {
            os.write_enum(1, self.format.value())?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScreenOut {
        ScreenOut::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ScreenOut_Format>>(
                    "format",
                    |m: &ScreenOut| { &m.format },
                    |m: &mut ScreenOut| { &mut m.format },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &ScreenOut| { &m.data },
                    |m: &mut ScreenOut| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ScreenOut>(
                    "ScreenOut",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ScreenOut {
        static mut instance: ::protobuf::lazy::Lazy<ScreenOut> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ScreenOut,
        };
        unsafe {
            instance.get(ScreenOut::new)
        }
    }
}

impl ::protobuf::Clear for ScreenOut {
    fn clear(&mut self) {
        self.clear_format();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScreenOut {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScreenOut {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ScreenOut_Format {
    FORMAT_UNSPECIFIED = 0,
    HTML = 1,
}

impl ::protobuf::ProtobufEnum for ScreenOut_Format {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ScreenOut_Format> {
        match value {
            0 => ::std::option::Option::Some(ScreenOut_Format::FORMAT_UNSPECIFIED),
            1 => ::std::option::Option::Some(ScreenOut_Format::HTML),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ScreenOut_Format] = &[
            ScreenOut_Format::FORMAT_UNSPECIFIED,
            ScreenOut_Format::HTML,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ScreenOut_Format", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ScreenOut_Format {
}

impl ::std::default::Default for ScreenOut_Format {
    fn default() -> Self {
        ScreenOut_Format::FORMAT_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for ScreenOut_Format {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceAction {
    // message fields
    pub device_request_json: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DeviceAction {
    pub fn new() -> DeviceAction {
        ::std::default::Default::default()
    }

    // string device_request_json = 1;

    pub fn clear_device_request_json(&mut self) {
        self.device_request_json.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_request_json(&mut self, v: ::std::string::String) {
        self.device_request_json = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_request_json(&mut self) -> &mut ::std::string::String {
        &mut self.device_request_json
    }

    // Take field
    pub fn take_device_request_json(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_request_json, ::std::string::String::new())
    }

    pub fn get_device_request_json(&self) -> &str {
        &self.device_request_json
    }
}

impl ::protobuf::Message for DeviceAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_request_json)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.device_request_json.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.device_request_json);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.device_request_json.is_empty() {
            os.write_string(1, &self.device_request_json)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceAction {
        DeviceAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "device_request_json",
                    |m: &DeviceAction| { &m.device_request_json },
                    |m: &mut DeviceAction| { &mut m.device_request_json },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceAction>(
                    "DeviceAction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceAction {
        static mut instance: ::protobuf::lazy::Lazy<DeviceAction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceAction,
        };
        unsafe {
            instance.get(DeviceAction::new)
        }
    }
}

impl ::protobuf::Clear for DeviceAction {
    fn clear(&mut self) {
        self.clear_device_request_json();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceAction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SpeechRecognitionResult {
    // message fields
    pub transcript: ::std::string::String,
    pub stability: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl SpeechRecognitionResult {
    pub fn new() -> SpeechRecognitionResult {
        ::std::default::Default::default()
    }

    // string transcript = 1;

    pub fn clear_transcript(&mut self) {
        self.transcript.clear();
    }

    // Param is passed by value, moved
    pub fn set_transcript(&mut self, v: ::std::string::String) {
        self.transcript = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transcript(&mut self) -> &mut ::std::string::String {
        &mut self.transcript
    }

    // Take field
    pub fn take_transcript(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.transcript, ::std::string::String::new())
    }

    pub fn get_transcript(&self) -> &str {
        &self.transcript
    }

    // float stability = 2;

    pub fn clear_stability(&mut self) {
        self.stability = 0.;
    }

    // Param is passed by value, moved
    pub fn set_stability(&mut self, v: f32) {
        self.stability = v;
    }

    pub fn get_stability(&self) -> f32 {
        self.stability
    }
}

impl ::protobuf::Message for SpeechRecognitionResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.transcript)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.stability = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.transcript.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.transcript);
        }
        if self.stability != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.transcript.is_empty() {
            os.write_string(1, &self.transcript)?;
        }
        if self.stability != 0. {
            os.write_float(2, self.stability)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpeechRecognitionResult {
        SpeechRecognitionResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "transcript",
                    |m: &SpeechRecognitionResult| { &m.transcript },
                    |m: &mut SpeechRecognitionResult| { &mut m.transcript },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "stability",
                    |m: &SpeechRecognitionResult| { &m.stability },
                    |m: &mut SpeechRecognitionResult| { &mut m.stability },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SpeechRecognitionResult>(
                    "SpeechRecognitionResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SpeechRecognitionResult {
        static mut instance: ::protobuf::lazy::Lazy<SpeechRecognitionResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SpeechRecognitionResult,
        };
        unsafe {
            instance.get(SpeechRecognitionResult::new)
        }
    }
}

impl ::protobuf::Clear for SpeechRecognitionResult {
    fn clear(&mut self) {
        self.clear_transcript();
        self.clear_stability();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SpeechRecognitionResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpeechRecognitionResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DialogStateOut {
    // message fields
    pub supplemental_display_text: ::std::string::String,
    pub conversation_state: ::std::vec::Vec<u8>,
    pub microphone_mode: DialogStateOut_MicrophoneMode,
    pub volume_percentage: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DialogStateOut {
    pub fn new() -> DialogStateOut {
        ::std::default::Default::default()
    }

    // string supplemental_display_text = 1;

    pub fn clear_supplemental_display_text(&mut self) {
        self.supplemental_display_text.clear();
    }

    // Param is passed by value, moved
    pub fn set_supplemental_display_text(&mut self, v: ::std::string::String) {
        self.supplemental_display_text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_supplemental_display_text(&mut self) -> &mut ::std::string::String {
        &mut self.supplemental_display_text
    }

    // Take field
    pub fn take_supplemental_display_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.supplemental_display_text, ::std::string::String::new())
    }

    pub fn get_supplemental_display_text(&self) -> &str {
        &self.supplemental_display_text
    }

    // bytes conversation_state = 2;

    pub fn clear_conversation_state(&mut self) {
        self.conversation_state.clear();
    }

    // Param is passed by value, moved
    pub fn set_conversation_state(&mut self, v: ::std::vec::Vec<u8>) {
        self.conversation_state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conversation_state(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.conversation_state
    }

    // Take field
    pub fn take_conversation_state(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.conversation_state, ::std::vec::Vec::new())
    }

    pub fn get_conversation_state(&self) -> &[u8] {
        &self.conversation_state
    }

    // .google.assistant.embedded.v1alpha2.DialogStateOut.MicrophoneMode microphone_mode = 3;

    pub fn clear_microphone_mode(&mut self) {
        self.microphone_mode = DialogStateOut_MicrophoneMode::MICROPHONE_MODE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_microphone_mode(&mut self, v: DialogStateOut_MicrophoneMode) {
        self.microphone_mode = v;
    }

    pub fn get_microphone_mode(&self) -> DialogStateOut_MicrophoneMode {
        self.microphone_mode
    }

    // int32 volume_percentage = 4;

    pub fn clear_volume_percentage(&mut self) {
        self.volume_percentage = 0;
    }

    // Param is passed by value, moved
    pub fn set_volume_percentage(&mut self, v: i32) {
        self.volume_percentage = v;
    }

    pub fn get_volume_percentage(&self) -> i32 {
        self.volume_percentage
    }
}

impl ::protobuf::Message for DialogStateOut {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.supplemental_display_text)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.conversation_state)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.microphone_mode, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.volume_percentage = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.supplemental_display_text.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.supplemental_display_text);
        }
        if !self.conversation_state.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.conversation_state);
        }
        if self.microphone_mode != DialogStateOut_MicrophoneMode::MICROPHONE_MODE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.microphone_mode);
        }
        if self.volume_percentage != 0 {
            my_size += ::protobuf::rt::value_size(4, self.volume_percentage, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.supplemental_display_text.is_empty() {
            os.write_string(1, &self.supplemental_display_text)?;
        }
        if !self.conversation_state.is_empty() {
            os.write_bytes(2, &self.conversation_state)?;
        }
        if self.microphone_mode != DialogStateOut_MicrophoneMode::MICROPHONE_MODE_UNSPECIFIED {
            os.write_enum(3, self.microphone_mode.value())?;
        }
        if self.volume_percentage != 0 {
            os.write_int32(4, self.volume_percentage)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DialogStateOut {
        DialogStateOut::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "supplemental_display_text",
                    |m: &DialogStateOut| { &m.supplemental_display_text },
                    |m: &mut DialogStateOut| { &mut m.supplemental_display_text },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "conversation_state",
                    |m: &DialogStateOut| { &m.conversation_state },
                    |m: &mut DialogStateOut| { &mut m.conversation_state },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DialogStateOut_MicrophoneMode>>(
                    "microphone_mode",
                    |m: &DialogStateOut| { &m.microphone_mode },
                    |m: &mut DialogStateOut| { &mut m.microphone_mode },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "volume_percentage",
                    |m: &DialogStateOut| { &m.volume_percentage },
                    |m: &mut DialogStateOut| { &mut m.volume_percentage },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DialogStateOut>(
                    "DialogStateOut",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DialogStateOut {
        static mut instance: ::protobuf::lazy::Lazy<DialogStateOut> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DialogStateOut,
        };
        unsafe {
            instance.get(DialogStateOut::new)
        }
    }
}

impl ::protobuf::Clear for DialogStateOut {
    fn clear(&mut self) {
        self.clear_supplemental_display_text();
        self.clear_conversation_state();
        self.clear_microphone_mode();
        self.clear_volume_percentage();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DialogStateOut {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DialogStateOut {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DialogStateOut_MicrophoneMode {
    MICROPHONE_MODE_UNSPECIFIED = 0,
    CLOSE_MICROPHONE = 1,
    DIALOG_FOLLOW_ON = 2,
}

impl ::protobuf::ProtobufEnum for DialogStateOut_MicrophoneMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DialogStateOut_MicrophoneMode> {
        match value {
            0 => ::std::option::Option::Some(DialogStateOut_MicrophoneMode::MICROPHONE_MODE_UNSPECIFIED),
            1 => ::std::option::Option::Some(DialogStateOut_MicrophoneMode::CLOSE_MICROPHONE),
            2 => ::std::option::Option::Some(DialogStateOut_MicrophoneMode::DIALOG_FOLLOW_ON),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DialogStateOut_MicrophoneMode] = &[
            DialogStateOut_MicrophoneMode::MICROPHONE_MODE_UNSPECIFIED,
            DialogStateOut_MicrophoneMode::CLOSE_MICROPHONE,
            DialogStateOut_MicrophoneMode::DIALOG_FOLLOW_ON,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DialogStateOut_MicrophoneMode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DialogStateOut_MicrophoneMode {
}

impl ::std::default::Default for DialogStateOut_MicrophoneMode {
    fn default() -> Self {
        DialogStateOut_MicrophoneMode::MICROPHONE_MODE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for DialogStateOut_MicrophoneMode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DebugConfig {
    // message fields
    pub return_debug_info: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DebugConfig {
    pub fn new() -> DebugConfig {
        ::std::default::Default::default()
    }

    // bool return_debug_info = 6;

    pub fn clear_return_debug_info(&mut self) {
        self.return_debug_info = false;
    }

    // Param is passed by value, moved
    pub fn set_return_debug_info(&mut self, v: bool) {
        self.return_debug_info = v;
    }

    pub fn get_return_debug_info(&self) -> bool {
        self.return_debug_info
    }
}

impl ::protobuf::Message for DebugConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_debug_info = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.return_debug_info != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.return_debug_info != false {
            os.write_bool(6, self.return_debug_info)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugConfig {
        DebugConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "return_debug_info",
                    |m: &DebugConfig| { &m.return_debug_info },
                    |m: &mut DebugConfig| { &mut m.return_debug_info },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DebugConfig>(
                    "DebugConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DebugConfig {
        static mut instance: ::protobuf::lazy::Lazy<DebugConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DebugConfig,
        };
        unsafe {
            instance.get(DebugConfig::new)
        }
    }
}

impl ::protobuf::Clear for DebugConfig {
    fn clear(&mut self) {
        self.clear_return_debug_info();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceLocation {
    // message oneof groups
    pub field_type: ::std::option::Option<DeviceLocation_oneof_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum DeviceLocation_oneof_type {
    coordinates(super::latlng::LatLng),
}

impl DeviceLocation {
    pub fn new() -> DeviceLocation {
        ::std::default::Default::default()
    }

    // .google.type.LatLng coordinates = 1;

    pub fn clear_coordinates(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_coordinates(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(DeviceLocation_oneof_type::coordinates(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_coordinates(&mut self, v: super::latlng::LatLng) {
        self.field_type = ::std::option::Option::Some(DeviceLocation_oneof_type::coordinates(v))
    }

    // Mutable pointer to the field.
    pub fn mut_coordinates(&mut self) -> &mut super::latlng::LatLng {
        if let ::std::option::Option::Some(DeviceLocation_oneof_type::coordinates(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(DeviceLocation_oneof_type::coordinates(super::latlng::LatLng::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(DeviceLocation_oneof_type::coordinates(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_coordinates(&mut self) -> super::latlng::LatLng {
        if self.has_coordinates() {
            match self.field_type.take() {
                ::std::option::Option::Some(DeviceLocation_oneof_type::coordinates(v)) => v,
                _ => panic!(),
            }
        } else {
            super::latlng::LatLng::new()
        }
    }

    pub fn get_coordinates(&self) -> &super::latlng::LatLng {
        match self.field_type {
            ::std::option::Option::Some(DeviceLocation_oneof_type::coordinates(ref v)) => v,
            _ => super::latlng::LatLng::default_instance(),
        }
    }
}

impl ::protobuf::Message for DeviceLocation {
    fn is_initialized(&self) -> bool {
        if let Some(DeviceLocation_oneof_type::coordinates(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(DeviceLocation_oneof_type::coordinates(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &DeviceLocation_oneof_type::coordinates(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &DeviceLocation_oneof_type::coordinates(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceLocation {
        DeviceLocation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::latlng::LatLng>(
                    "coordinates",
                    DeviceLocation::has_coordinates,
                    DeviceLocation::get_coordinates,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceLocation>(
                    "DeviceLocation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceLocation {
        static mut instance: ::protobuf::lazy::Lazy<DeviceLocation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceLocation,
        };
        unsafe {
            instance.get(DeviceLocation::new)
        }
    }
}

impl ::protobuf::Clear for DeviceLocation {
    fn clear(&mut self) {
        self.clear_coordinates();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceLocation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceLocation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n;google/assistant/embedded/v1alpha2/embedded_assistant.proto\x12\"goog\
    le.assistant.embedded.v1alpha2\x1a\x1cgoogle/api/annotations.proto\x1a\
    \x18google/type/latlng.proto\"\x80\x01\n\rAssistRequest\x12J\n\x06config\
    \x18\x01\x20\x01(\x0b20.google.assistant.embedded.v1alpha2.AssistConfigH\
    \0R\x06config\x12\x1b\n\x08audio_in\x18\x02\x20\x01(\x0cH\0R\x07audioInB\
    \x06\n\x04type\"\xac\x05\n\x0eAssistResponse\x12[\n\nevent_type\x18\x01\
    \x20\x01(\x0e2<.google.assistant.embedded.v1alpha2.AssistResponse.EventT\
    ypeR\teventType\x12I\n\taudio_out\x18\x03\x20\x01(\x0b2,.google.assistan\
    t.embedded.v1alpha2.AudioOutR\x08audioOut\x12L\n\nscreen_out\x18\x04\x20\
    \x01(\x0b2-.google.assistant.embedded.v1alpha2.ScreenOutR\tscreenOut\x12\
    U\n\rdevice_action\x18\x06\x20\x01(\x0b20.google.assistant.embedded.v1al\
    pha2.DeviceActionR\x0cdeviceAction\x12b\n\x0espeech_results\x18\x02\x20\
    \x03(\x0b2;.google.assistant.embedded.v1alpha2.SpeechRecognitionResultR\
    \rspeechResults\x12\\\n\x10dialog_state_out\x18\x05\x20\x01(\x0b22.googl\
    e.assistant.embedded.v1alpha2.DialogStateOutR\x0edialogStateOut\x12L\n\n\
    debug_info\x18\x08\x20\x01(\x0b2-.google.assistant.embedded.v1alpha2.Deb\
    ugInfoR\tdebugInfo\"=\n\tEventType\x12\x1a\n\x16EVENT_TYPE_UNSPECIFIED\
    \x10\0\x12\x14\n\x10END_OF_UTTERANCE\x10\x01\"I\n\tDebugInfo\x12<\n\x1ba\
    og_agent_to_assistant_json\x18\x01\x20\x01(\tR\x17aogAgentToAssistantJso\
    n\"\xd9\x04\n\x0cAssistConfig\x12[\n\x0faudio_in_config\x18\x01\x20\x01(\
    \x0b21.google.assistant.embedded.v1alpha2.AudioInConfigH\0R\raudioInConf\
    ig\x12\x1f\n\ntext_query\x18\x06\x20\x01(\tH\0R\ttextQuery\x12\\\n\x10au\
    dio_out_config\x18\x02\x20\x01(\x0b22.google.assistant.embedded.v1alpha2\
    .AudioOutConfigR\x0eaudioOutConfig\x12_\n\x11screen_out_config\x18\x08\
    \x20\x01(\x0b23.google.assistant.embedded.v1alpha2.ScreenOutConfigR\x0fs\
    creenOutConfig\x12Y\n\x0fdialog_state_in\x18\x03\x20\x01(\x0b21.google.a\
    ssistant.embedded.v1alpha2.DialogStateInR\rdialogStateIn\x12U\n\rdevice_\
    config\x18\x04\x20\x01(\x0b20.google.assistant.embedded.v1alpha2.DeviceC\
    onfigR\x0cdeviceConfig\x12R\n\x0cdebug_config\x18\x05\x20\x01(\x0b2/.goo\
    gle.assistant.embedded.v1alpha2.DebugConfigR\x0bdebugConfigB\x06\n\x04ty\
    pe\"\xd1\x01\n\rAudioInConfig\x12V\n\x08encoding\x18\x01\x20\x01(\x0e2:.\
    google.assistant.embedded.v1alpha2.AudioInConfig.EncodingR\x08encoding\
    \x12*\n\x11sample_rate_hertz\x18\x02\x20\x01(\x05R\x0fsampleRateHertz\"<\
    \n\x08Encoding\x12\x18\n\x14ENCODING_UNSPECIFIED\x10\0\x12\x0c\n\x08LINE\
    AR16\x10\x01\x12\x08\n\x04FLAC\x10\x02\"\x90\x02\n\x0eAudioOutConfig\x12\
    W\n\x08encoding\x18\x01\x20\x01(\x0e2;.google.assistant.embedded.v1alpha\
    2.AudioOutConfig.EncodingR\x08encoding\x12*\n\x11sample_rate_hertz\x18\
    \x02\x20\x01(\x05R\x0fsampleRateHertz\x12+\n\x11volume_percentage\x18\
    \x03\x20\x01(\x05R\x10volumePercentage\"L\n\x08Encoding\x12\x18\n\x14ENC\
    ODING_UNSPECIFIED\x10\0\x12\x0c\n\x08LINEAR16\x10\x01\x12\x07\n\x03MP3\
    \x10\x02\x12\x0f\n\x0bOPUS_IN_OGG\x10\x03\"\xb3\x01\n\x0fScreenOutConfig\
    \x12_\n\x0bscreen_mode\x18\x01\x20\x01(\x0e2>.google.assistant.embedded.\
    v1alpha2.ScreenOutConfig.ScreenModeR\nscreenMode\"?\n\nScreenMode\x12\
    \x1b\n\x17SCREEN_MODE_UNSPECIFIED\x10\0\x12\x07\n\x03OFF\x10\x01\x12\x0b\
    \n\x07PLAYING\x10\x03\"\xf0\x01\n\rDialogStateIn\x12-\n\x12conversation_\
    state\x18\x01\x20\x01(\x0cR\x11conversationState\x12#\n\rlanguage_code\
    \x18\x02\x20\x01(\tR\x0clanguageCode\x12[\n\x0fdevice_location\x18\x05\
    \x20\x01(\x0b22.google.assistant.embedded.v1alpha2.DeviceLocationR\x0ede\
    viceLocation\x12.\n\x13is_new_conversation\x18\x07\x20\x01(\x08R\x11isNe\
    wConversation\"S\n\x0cDeviceConfig\x12\x1b\n\tdevice_id\x18\x01\x20\x01(\
    \tR\x08deviceId\x12&\n\x0fdevice_model_id\x18\x03\x20\x01(\tR\rdeviceMod\
    elId\")\n\x08AudioOut\x12\x1d\n\naudio_data\x18\x01\x20\x01(\x0cR\taudio\
    Data\"\x99\x01\n\tScreenOut\x12L\n\x06format\x18\x01\x20\x01(\x0e24.goog\
    le.assistant.embedded.v1alpha2.ScreenOut.FormatR\x06format\x12\x12\n\x04\
    data\x18\x02\x20\x01(\x0cR\x04data\"*\n\x06Format\x12\x16\n\x12FORMAT_UN\
    SPECIFIED\x10\0\x12\x08\n\x04HTML\x10\x01\">\n\x0cDeviceAction\x12.\n\
    \x13device_request_json\x18\x01\x20\x01(\tR\x11deviceRequestJson\"W\n\
    \x17SpeechRecognitionResult\x12\x1e\n\ntranscript\x18\x01\x20\x01(\tR\nt\
    ranscript\x12\x1c\n\tstability\x18\x02\x20\x01(\x02R\tstability\"\xf3\
    \x02\n\x0eDialogStateOut\x12:\n\x19supplemental_display_text\x18\x01\x20\
    \x01(\tR\x17supplementalDisplayText\x12-\n\x12conversation_state\x18\x02\
    \x20\x01(\x0cR\x11conversationState\x12j\n\x0fmicrophone_mode\x18\x03\
    \x20\x01(\x0e2A.google.assistant.embedded.v1alpha2.DialogStateOut.Microp\
    honeModeR\x0emicrophoneMode\x12+\n\x11volume_percentage\x18\x04\x20\x01(\
    \x05R\x10volumePercentage\"]\n\x0eMicrophoneMode\x12\x1f\n\x1bMICROPHONE\
    _MODE_UNSPECIFIED\x10\0\x12\x14\n\x10CLOSE_MICROPHONE\x10\x01\x12\x14\n\
    \x10DIALOG_FOLLOW_ON\x10\x02\"9\n\x0bDebugConfig\x12*\n\x11return_debug_\
    info\x18\x06\x20\x01(\x08R\x0freturnDebugInfo\"Q\n\x0eDeviceLocation\x12\
    7\n\x0bcoordinates\x18\x01\x20\x01(\x0b2\x13.google.type.LatLngH\0R\x0bc\
    oordinatesB\x06\n\x04type2\x88\x01\n\x11EmbeddedAssistant\x12s\n\x06Assi\
    st\x121.google.assistant.embedded.v1alpha2.AssistRequest\x1a2.google.ass\
    istant.embedded.v1alpha2.AssistResponse(\x010\x01B\x8f\x01\n&com.google.\
    assistant.embedded.v1alpha2B\x0eAssistantProtoP\x01ZJgoogle.golang.org/g\
    enproto/googleapis/assistant/embedded/v1alpha2;embedded\xa2\x02\x06ASTSD\
    KJ\xda\xa4\x01\n\x07\x12\x05\x0e\0\xcd\x03\x01\n\xbd\x04\n\x01\x0c\x12\
    \x03\x0e\0\x122\xb2\x04\x20Copyright\x202018\x20Google\x20Inc.\n\n\x20Li\
    censed\x20under\x20the\x20Apache\x20License,\x20Version\x202.0\x20(the\
    \x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\x20file\x20excep\
    t\x20in\x20compliance\x20with\x20the\x20License.\n\x20You\x20may\x20obta\
    in\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20\x20htt\
    p://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\x20by\
    \x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20softwar\
    e\n\x20distributed\x20under\x20the\x20License\x20is\x20distributed\x20on\
    \x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CON\
    DITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\x20implied.\n\
    \x20See\x20the\x20License\x20for\x20the\x20specific\x20language\x20gover\
    ning\x20permissions\x20and\n\x20limitations\x20under\x20the\x20License.\
    \n\n\x08\n\x01\x02\x12\x03\x10\x08*\n\t\n\x02\x03\0\x12\x03\x12\x07%\n\t\
    \n\x02\x03\x01\x12\x03\x13\x07!\n\x08\n\x01\x08\x12\x03\x15\0a\n\x0b\n\
    \x04\x08\xe7\x07\0\x12\x03\x15\0a\n\x0c\n\x05\x08\xe7\x07\0\x02\x12\x03\
    \x15\x07\x11\n\r\n\x06\x08\xe7\x07\0\x02\0\x12\x03\x15\x07\x11\n\x0e\n\
    \x07\x08\xe7\x07\0\x02\0\x01\x12\x03\x15\x07\x11\n\x0c\n\x05\x08\xe7\x07\
    \0\x07\x12\x03\x15\x14`\n\x08\n\x01\x08\x12\x03\x16\0\"\n\x0b\n\x04\x08\
    \xe7\x07\x01\x12\x03\x16\0\"\n\x0c\n\x05\x08\xe7\x07\x01\x02\x12\x03\x16\
    \x07\x1a\n\r\n\x06\x08\xe7\x07\x01\x02\0\x12\x03\x16\x07\x1a\n\x0e\n\x07\
    \x08\xe7\x07\x01\x02\0\x01\x12\x03\x16\x07\x1a\n\x0c\n\x05\x08\xe7\x07\
    \x01\x03\x12\x03\x16\x1d!\n\x08\n\x01\x08\x12\x03\x17\0/\n\x0b\n\x04\x08\
    \xe7\x07\x02\x12\x03\x17\0/\n\x0c\n\x05\x08\xe7\x07\x02\x02\x12\x03\x17\
    \x07\x1b\n\r\n\x06\x08\xe7\x07\x02\x02\0\x12\x03\x17\x07\x1b\n\x0e\n\x07\
    \x08\xe7\x07\x02\x02\0\x01\x12\x03\x17\x07\x1b\n\x0c\n\x05\x08\xe7\x07\
    \x02\x07\x12\x03\x17\x1e.\n\x08\n\x01\x08\x12\x03\x18\0?\n\x0b\n\x04\x08\
    \xe7\x07\x03\x12\x03\x18\0?\n\x0c\n\x05\x08\xe7\x07\x03\x02\x12\x03\x18\
    \x07\x13\n\r\n\x06\x08\xe7\x07\x03\x02\0\x12\x03\x18\x07\x13\n\x0e\n\x07\
    \x08\xe7\x07\x03\x02\0\x01\x12\x03\x18\x07\x13\n\x0c\n\x05\x08\xe7\x07\
    \x03\x07\x12\x03\x18\x16>\n\x08\n\x01\x08\x12\x03\x19\0$\n\x0b\n\x04\x08\
    \xe7\x07\x04\x12\x03\x19\0$\n\x0c\n\x05\x08\xe7\x07\x04\x02\x12\x03\x19\
    \x07\x18\n\r\n\x06\x08\xe7\x07\x04\x02\0\x12\x03\x19\x07\x18\n\x0e\n\x07\
    \x08\xe7\x07\x04\x02\0\x01\x12\x03\x19\x07\x18\n\x0c\n\x05\x08\xe7\x07\
    \x04\x07\x12\x03\x19\x1b#\n?\n\x02\x06\0\x12\x04\x1d\0J\x01\x1a3\x20Serv\
    ice\x20that\x20implements\x20the\x20Google\x20Assistant\x20API.\n\n\n\n\
    \x03\x06\0\x01\x12\x03\x1d\x08\x19\n\xee\r\n\x04\x06\0\x02\0\x12\x03I\
    \x02C\x1a\xe0\r\x20Initiates\x20or\x20continues\x20a\x20conversation\x20\
    with\x20the\x20embedded\x20Assistant\x20Service.\n\x20Each\x20call\x20pe\
    rforms\x20one\x20round-trip,\x20sending\x20an\x20audio\x20request\x20to\
    \x20the\x20service\n\x20and\x20receiving\x20the\x20audio\x20response.\
    \x20Uses\x20bidirectional\x20streaming\x20to\x20receive\n\x20results,\
    \x20such\x20as\x20the\x20`END_OF_UTTERANCE`\x20event,\x20while\x20sendin\
    g\x20audio.\n\n\x20A\x20conversation\x20is\x20one\x20or\x20more\x20gRPC\
    \x20connections,\x20each\x20consisting\x20of\x20several\n\x20streamed\
    \x20requests\x20and\x20responses.\n\x20For\x20example,\x20the\x20user\
    \x20says\x20*Add\x20to\x20my\x20shopping\x20list*\x20and\x20the\x20Assis\
    tant\n\x20responds\x20*What\x20do\x20you\x20want\x20to\x20add?*.\x20The\
    \x20sequence\x20of\x20streamed\x20requests\x20and\n\x20responses\x20in\
    \x20the\x20first\x20gRPC\x20message\x20could\x20be:\n\n\x20*\x20\x20\x20\
    AssistRequest.config\n\x20*\x20\x20\x20AssistRequest.audio_in\n\x20*\x20\
    \x20\x20AssistRequest.audio_in\n\x20*\x20\x20\x20AssistRequest.audio_in\
    \n\x20*\x20\x20\x20AssistRequest.audio_in\n\x20*\x20\x20\x20AssistRespon\
    se.event_type.END_OF_UTTERANCE\n\x20*\x20\x20\x20AssistResponse.speech_r\
    esults.transcript\x20\"add\x20to\x20my\x20shopping\x20list\"\n\x20*\x20\
    \x20\x20AssistResponse.dialog_state_out.microphone_mode.DIALOG_FOLLOW_ON\
    \n\x20*\x20\x20\x20AssistResponse.audio_out\n\x20*\x20\x20\x20AssistResp\
    onse.audio_out\n\x20*\x20\x20\x20AssistResponse.audio_out\n\n\n\x20The\
    \x20user\x20then\x20says\x20*bagels*\x20and\x20the\x20Assistant\x20respo\
    nds\n\x20*OK,\x20I've\x20added\x20bagels\x20to\x20your\x20shopping\x20li\
    st*.\x20This\x20is\x20sent\x20as\x20another\x20gRPC\n\x20connection\x20c\
    all\x20to\x20the\x20`Assist`\x20method,\x20again\x20with\x20streamed\x20\
    requests\x20and\n\x20responses,\x20such\x20as:\n\n\x20*\x20\x20\x20Assis\
    tRequest.config\n\x20*\x20\x20\x20AssistRequest.audio_in\n\x20*\x20\x20\
    \x20AssistRequest.audio_in\n\x20*\x20\x20\x20AssistRequest.audio_in\n\
    \x20*\x20\x20\x20AssistResponse.event_type.END_OF_UTTERANCE\n\x20*\x20\
    \x20\x20AssistResponse.dialog_state_out.microphone_mode.CLOSE_MICROPHONE\
    \n\x20*\x20\x20\x20AssistResponse.audio_out\n\x20*\x20\x20\x20AssistResp\
    onse.audio_out\n\x20*\x20\x20\x20AssistResponse.audio_out\n\x20*\x20\x20\
    \x20AssistResponse.audio_out\n\n\x20Although\x20the\x20precise\x20order\
    \x20of\x20responses\x20is\x20not\x20guaranteed,\x20sequential\n\x20`Assi\
    stResponse.audio_out`\x20messages\x20will\x20always\x20contain\x20sequen\
    tial\x20portions\n\x20of\x20audio.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\
    I\x06\x0c\n\x0c\n\x05\x06\0\x02\0\x05\x12\x03I\r\x13\n\x0c\n\x05\x06\0\
    \x02\0\x02\x12\x03I\x14!\n\x0c\n\x05\x06\0\x02\0\x06\x12\x03I,2\n\x0c\n\
    \x05\x06\0\x02\0\x03\x12\x03I3A\n\xc3\x02\n\x02\x04\0\x12\x04Q\0c\x01\
    \x1a\xb6\x02\x20The\x20top-level\x20message\x20sent\x20by\x20the\x20clie\
    nt.\x20Clients\x20must\x20send\x20at\x20least\x20two,\x20and\n\x20typica\
    lly\x20numerous\x20`AssistRequest`\x20messages.\x20The\x20first\x20messa\
    ge\x20must\n\x20contain\x20a\x20`config`\x20message\x20and\x20must\x20no\
    t\x20contain\x20`audio_in`\x20data.\x20All\n\x20subsequent\x20messages\
    \x20must\x20contain\x20`audio_in`\x20data\x20and\x20must\x20not\x20conta\
    in\x20a\n\x20`config`\x20message.\n\n\n\n\x03\x04\0\x01\x12\x03Q\x08\x15\
    \nV\n\x04\x04\0\x08\0\x12\x04S\x02b\x03\x1aH\x20Exactly\x20one\x20of\x20\
    these\x20fields\x20must\x20be\x20specified\x20in\x20each\x20`AssistReque\
    st`.\n\n\x0c\n\x05\x04\0\x08\0\x01\x12\x03S\x08\x0c\n\xbb\x01\n\x04\x04\
    \0\x02\0\x12\x03W\x04\x1c\x1a\xad\x01\x20The\x20`config`\x20message\x20p\
    rovides\x20information\x20to\x20the\x20recognizer\x20that\n\x20specifies\
    \x20how\x20to\x20process\x20the\x20request.\n\x20The\x20first\x20`Assist\
    Request`\x20message\x20must\x20contain\x20a\x20`config`\x20message.\n\n\
    \x0c\n\x05\x04\0\x02\0\x06\x12\x03W\x04\x10\n\x0c\n\x05\x04\0\x02\0\x01\
    \x12\x03W\x11\x17\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03W\x1a\x1b\n\xeb\x03\
    \n\x04\x04\0\x02\x01\x12\x03a\x04\x17\x1a\xdd\x03\x20The\x20audio\x20dat\
    a\x20to\x20be\x20recognized.\x20Sequential\x20chunks\x20of\x20audio\x20d\
    ata\x20are\x20sent\n\x20in\x20sequential\x20`AssistRequest`\x20messages.\
    \x20The\x20first\x20`AssistRequest`\n\x20message\x20must\x20not\x20conta\
    in\x20`audio_in`\x20data\x20and\x20all\x20subsequent\n\x20`AssistRequest\
    `\x20messages\x20must\x20contain\x20`audio_in`\x20data.\x20The\x20audio\
    \x20bytes\n\x20must\x20be\x20encoded\x20as\x20specified\x20in\x20`AudioI\
    nConfig`.\n\x20Audio\x20must\x20be\x20sent\x20at\x20approximately\x20rea\
    l-time\x20(16000\x20samples\x20per\x20second).\n\x20An\x20error\x20will\
    \x20be\x20returned\x20if\x20audio\x20is\x20sent\x20significantly\x20fast\
    er\x20or\n\x20slower.\n\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03a\x04\t\n\
    \x0c\n\x05\x04\0\x02\x01\x01\x12\x03a\n\x12\n\x0c\n\x05\x04\0\x02\x01\
    \x03\x12\x03a\x15\x16\n\x91\x01\n\x02\x04\x01\x12\x05g\0\x92\x01\x01\x1a\
    \x83\x01\x20The\x20top-level\x20message\x20received\x20by\x20the\x20clie\
    nt.\x20A\x20series\x20of\x20one\x20or\x20more\n\x20`AssistResponse`\x20m\
    essages\x20are\x20streamed\x20back\x20to\x20the\x20client.\n\n\n\n\x03\
    \x04\x01\x01\x12\x03g\x08\x16\n,\n\x04\x04\x01\x04\0\x12\x04i\x02t\x03\
    \x1a\x1e\x20Indicates\x20the\x20type\x20of\x20event.\n\n\x0c\n\x05\x04\
    \x01\x04\0\x01\x12\x03i\x07\x10\n$\n\x06\x04\x01\x04\0\x02\0\x12\x03k\
    \x04\x1f\x1a\x15\x20No\x20event\x20specified.\n\n\x0e\n\x07\x04\x01\x04\
    \0\x02\0\x01\x12\x03k\x04\x1a\n\x0e\n\x07\x04\x01\x04\0\x02\0\x02\x12\
    \x03k\x1d\x1e\n\xaa\x03\n\x06\x04\x01\x04\0\x02\x01\x12\x03s\x04\x19\x1a\
    \x9a\x03\x20This\x20event\x20indicates\x20that\x20the\x20server\x20has\
    \x20detected\x20the\x20end\x20of\x20the\x20user's\n\x20speech\x20utteran\
    ce\x20and\x20expects\x20no\x20additional\x20speech.\x20Therefore,\x20the\
    \x20server\n\x20will\x20not\x20process\x20additional\x20audio\x20(althou\
    gh\x20it\x20may\x20subsequently\x20return\n\x20additional\x20results).\
    \x20The\x20client\x20should\x20stop\x20sending\x20additional\x20audio\n\
    \x20data,\x20half-close\x20the\x20gRPC\x20connection,\x20and\x20wait\x20\
    for\x20any\x20additional\x20results\n\x20until\x20the\x20server\x20close\
    s\x20the\x20gRPC\x20connection.\n\n\x0e\n\x07\x04\x01\x04\0\x02\x01\x01\
    \x12\x03s\x04\x14\n\x0e\n\x07\x04\x01\x04\0\x02\x01\x02\x12\x03s\x17\x18\
    \n9\n\x04\x04\x01\x02\0\x12\x03w\x02\x1b\x1a,\x20*Output-only*\x20Indica\
    tes\x20the\x20type\x20of\x20event.\n\n\r\n\x05\x04\x01\x02\0\x04\x12\x04\
    w\x02t\x03\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03w\x02\x0b\n\x0c\n\x05\
    \x04\x01\x02\0\x01\x12\x03w\x0c\x16\n\x0c\n\x05\x04\x01\x02\0\x03\x12\
    \x03w\x19\x1a\nX\n\x04\x04\x01\x02\x01\x12\x03z\x02\x19\x1aK\x20*Output-\
    only*\x20The\x20audio\x20containing\x20the\x20Assistant's\x20response\
    \x20to\x20the\x20query.\n\n\r\n\x05\x04\x01\x02\x01\x04\x12\x04z\x02w\
    \x1b\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03z\x02\n\n\x0c\n\x05\x04\x01\
    \x02\x01\x01\x12\x03z\x0b\x14\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03z\
    \x17\x18\nS\n\x04\x04\x01\x02\x02\x12\x03}\x02\x1b\x1aF\x20*Output-only*\
    \x20Contains\x20the\x20Assistant's\x20visual\x20response\x20to\x20the\
    \x20query.\n\n\r\n\x05\x04\x01\x02\x02\x04\x12\x04}\x02z\x19\n\x0c\n\x05\
    \x04\x01\x02\x02\x06\x12\x03}\x02\x0b\n\x0c\n\x05\x04\x01\x02\x02\x01\
    \x12\x03}\x0c\x16\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03}\x19\x1a\n}\n\
    \x04\x04\x01\x02\x03\x12\x04\x81\x01\x02!\x1ao\x20*Output-only*\x20Conta\
    ins\x20the\x20action\x20triggered\x20by\x20the\x20query\x20with\x20the\n\
    \x20appropriate\x20payloads\x20and\x20semantic\x20parsing.\n\n\x0e\n\x05\
    \x04\x01\x02\x03\x04\x12\x05\x81\x01\x02}\x1b\n\r\n\x05\x04\x01\x02\x03\
    \x06\x12\x04\x81\x01\x02\x0e\n\r\n\x05\x04\x01\x02\x03\x01\x12\x04\x81\
    \x01\x0f\x1c\n\r\n\x05\x04\x01\x02\x03\x03\x12\x04\x81\x01\x1f\x20\n\xf0\
    \x03\n\x04\x04\x01\x02\x04\x12\x04\x8a\x01\x026\x1a\xe1\x03\x20*Output-o\
    nly*\x20This\x20repeated\x20list\x20contains\x20zero\x20or\x20more\x20sp\
    eech\x20recognition\n\x20results\x20that\x20correspond\x20to\x20consecut\
    ive\x20portions\x20of\x20the\x20audio\x20currently\n\x20being\x20process\
    ed,\x20starting\x20with\x20the\x20portion\x20corresponding\x20to\x20the\
    \x20earliest\n\x20audio\x20(and\x20most\x20stable\x20portion)\x20to\x20t\
    he\x20portion\x20corresponding\x20to\x20the\x20most\n\x20recent\x20audio\
    .\x20The\x20strings\x20can\x20be\x20concatenated\x20to\x20view\x20the\
    \x20full\n\x20in-progress\x20response.\x20When\x20the\x20speech\x20recog\
    nition\x20completes,\x20this\x20list\n\x20will\x20contain\x20one\x20item\
    \x20with\x20`stability`\x20of\x20`1.0`.\n\n\r\n\x05\x04\x01\x02\x04\x04\
    \x12\x04\x8a\x01\x02\n\n\r\n\x05\x04\x01\x02\x04\x06\x12\x04\x8a\x01\x0b\
    \"\n\r\n\x05\x04\x01\x02\x04\x01\x12\x04\x8a\x01#1\n\r\n\x05\x04\x01\x02\
    \x04\x03\x12\x04\x8a\x0145\nJ\n\x04\x04\x01\x02\x05\x12\x04\x8d\x01\x02&\
    \x1a<\x20*Output-only*\x20Contains\x20output\x20related\x20to\x20the\x20\
    user's\x20query.\n\n\x0f\n\x05\x04\x01\x02\x05\x04\x12\x06\x8d\x01\x02\
    \x8a\x016\n\r\n\x05\x04\x01\x02\x05\x06\x12\x04\x8d\x01\x02\x10\n\r\n\
    \x05\x04\x01\x02\x05\x01\x12\x04\x8d\x01\x11!\n\r\n\x05\x04\x01\x02\x05\
    \x03\x12\x04\x8d\x01$%\nv\n\x04\x04\x01\x02\x06\x12\x04\x91\x01\x02\x1b\
    \x1ah\x20*Output-only*\x20Debugging\x20info\x20for\x20developer.\x20Only\
    \x20returned\x20if\x20request\x20set\n\x20`return_debug_info`\x20to\x20t\
    rue.\n\n\x0f\n\x05\x04\x01\x02\x06\x04\x12\x06\x91\x01\x02\x8d\x01&\n\r\
    \n\x05\x04\x01\x02\x06\x06\x12\x04\x91\x01\x02\x0b\n\r\n\x05\x04\x01\x02\
    \x06\x01\x12\x04\x91\x01\x0c\x16\n\r\n\x05\x04\x01\x02\x06\x03\x12\x04\
    \x91\x01\x19\x1a\nd\n\x02\x04\x02\x12\x06\x96\x01\0\x9d\x01\x01\x1aV\x20\
    Debug\x20info\x20for\x20developer.\x20Only\x20returned\x20if\x20request\
    \x20set\x20`return_debug_info`\n\x20to\x20true.\n\n\x0b\n\x03\x04\x02\
    \x01\x12\x04\x96\x01\x08\x11\n\x9f\x02\n\x04\x04\x02\x02\0\x12\x04\x9c\
    \x01\x02)\x1a\x90\x02\x20The\x20original\x20JSON\x20response\x20from\x20\
    an\x20Action-on-Google\x20agent\x20to\x20Google\x20server.\n\x20See\n\
    \x20https://developers.google.com/actions/reference/rest/Shared.Types/Ap\
    pResponse.\n\x20It\x20will\x20only\x20be\x20populated\x20if\x20the\x20re\
    quest\x20maker\x20owns\x20the\x20AoG\x20project\x20and\x20the\n\x20AoG\
    \x20project\x20is\x20in\x20preview\x20mode.\n\n\x0f\n\x05\x04\x02\x02\0\
    \x04\x12\x06\x9c\x01\x02\x96\x01\x13\n\r\n\x05\x04\x02\x02\0\x05\x12\x04\
    \x9c\x01\x02\x08\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\x9c\x01\t$\n\r\n\
    \x05\x04\x02\x02\0\x03\x12\x04\x9c\x01'(\nF\n\x02\x04\x03\x12\x06\xa0\
    \x01\0\xba\x01\x01\x1a8\x20Specifies\x20how\x20to\x20process\x20the\x20`\
    AssistRequest`\x20messages.\n\n\x0b\n\x03\x04\x03\x01\x12\x04\xa0\x01\
    \x08\x14\n\x0e\n\x04\x04\x03\x08\0\x12\x06\xa1\x01\x02\xa9\x01\x03\n\r\n\
    \x05\x04\x03\x08\0\x01\x12\x04\xa1\x01\x08\x0c\n\xd8\x01\n\x04\x04\x03\
    \x02\0\x12\x04\xa4\x01\x04&\x1a\xc9\x01\x20Specifies\x20how\x20to\x20pro\
    cess\x20the\x20subsequent\x20incoming\x20audio.\x20Required\x20if\n\x20[\
    AssistRequest.audio_in][google.assistant.embedded.v1alpha2.AssistRequest\
    .audio_in]\x20bytes\x20will\x20be\x20provided\x20in\x20subsequent\x20req\
    uests.\n\n\r\n\x05\x04\x03\x02\0\x06\x12\x04\xa4\x01\x04\x11\n\r\n\x05\
    \x04\x03\x02\0\x01\x12\x04\xa4\x01\x12!\n\r\n\x05\x04\x03\x02\0\x03\x12\
    \x04\xa4\x01$%\n\x89\x01\n\x04\x04\x03\x02\x01\x12\x04\xa8\x01\x04\x1a\
    \x1a{\x20The\x20text\x20input\x20to\x20be\x20sent\x20to\x20the\x20Assist\
    ant.\x20This\x20can\x20be\x20populated\x20from\x20a\n\x20text\x20interfa\
    ce\x20if\x20audio\x20input\x20is\x20not\x20available.\n\n\r\n\x05\x04\
    \x03\x02\x01\x05\x12\x04\xa8\x01\x04\n\n\r\n\x05\x04\x03\x02\x01\x01\x12\
    \x04\xa8\x01\x0b\x15\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\xa8\x01\x18\
    \x19\nS\n\x04\x04\x03\x02\x02\x12\x04\xac\x01\x02&\x1aE\x20*Required*\
    \x20Specifies\x20how\x20to\x20format\x20the\x20audio\x20that\x20will\x20\
    be\x20returned.\n\n\x0f\n\x05\x04\x03\x02\x02\x04\x12\x06\xac\x01\x02\
    \xa9\x01\x03\n\r\n\x05\x04\x03\x02\x02\x06\x12\x04\xac\x01\x02\x10\n\r\n\
    \x05\x04\x03\x02\x02\x01\x12\x04\xac\x01\x11!\n\r\n\x05\x04\x03\x02\x02\
    \x03\x12\x04\xac\x01$%\nm\n\x04\x04\x03\x02\x03\x12\x04\xb0\x01\x02(\x1a\
    _\x20*Optional*\x20Specifies\x20the\x20desired\x20format\x20to\x20use\
    \x20when\x20server\x20returns\x20a\n\x20visual\x20screen\x20response.\n\
    \n\x0f\n\x05\x04\x03\x02\x03\x04\x12\x06\xb0\x01\x02\xac\x01&\n\r\n\x05\
    \x04\x03\x02\x03\x06\x12\x04\xb0\x01\x02\x11\n\r\n\x05\x04\x03\x02\x03\
    \x01\x12\x04\xb0\x01\x12#\n\r\n\x05\x04\x03\x02\x03\x03\x12\x04\xb0\x01&\
    '\n?\n\x04\x04\x03\x02\x04\x12\x04\xb3\x01\x02$\x1a1\x20*Required*\x20Re\
    presents\x20the\x20current\x20dialog\x20state.\n\n\x0f\n\x05\x04\x03\x02\
    \x04\x04\x12\x06\xb3\x01\x02\xb0\x01(\n\r\n\x05\x04\x03\x02\x04\x06\x12\
    \x04\xb3\x01\x02\x0f\n\r\n\x05\x04\x03\x02\x04\x01\x12\x04\xb3\x01\x10\
    \x1f\n\r\n\x05\x04\x03\x02\x04\x03\x12\x04\xb3\x01\"#\nP\n\x04\x04\x03\
    \x02\x05\x12\x04\xb6\x01\x02!\x1aB\x20Device\x20configuration\x20that\
    \x20uniquely\x20identifies\x20a\x20specific\x20device.\n\n\x0f\n\x05\x04\
    \x03\x02\x05\x04\x12\x06\xb6\x01\x02\xb3\x01$\n\r\n\x05\x04\x03\x02\x05\
    \x06\x12\x04\xb6\x01\x02\x0e\n\r\n\x05\x04\x03\x02\x05\x01\x12\x04\xb6\
    \x01\x0f\x1c\n\r\n\x05\x04\x03\x02\x05\x03\x12\x04\xb6\x01\x1f\x20\nK\n\
    \x04\x04\x03\x02\x06\x12\x04\xb9\x01\x02\x1f\x1a=\x20*Optional*\x20Debug\
    ging\x20parameters\x20for\x20the\x20whole\x20`Assist`\x20RPC.\n\n\x0f\n\
    \x05\x04\x03\x02\x06\x04\x12\x06\xb9\x01\x02\xb6\x01!\n\r\n\x05\x04\x03\
    \x02\x06\x06\x12\x04\xb9\x01\x02\r\n\r\n\x05\x04\x03\x02\x06\x01\x12\x04\
    \xb9\x01\x0e\x1a\n\r\n\x05\x04\x03\x02\x06\x03\x12\x04\xb9\x01\x1d\x1e\n\
    \x8e\x02\n\x02\x04\x04\x12\x06\xbf\x01\0\xdd\x01\x01\x1a\xff\x01\x20Spec\
    ifies\x20how\x20to\x20process\x20the\x20`audio_in`\x20data\x20that\x20wi\
    ll\x20be\x20provided\x20in\n\x20subsequent\x20requests.\x20For\x20recomm\
    ended\x20settings,\x20see\x20the\x20Google\x20Assistant\x20SDK\n\x20[bes\
    t\x20practices](https://developers.google.com/assistant/sdk/guides/servi\
    ce/python/best-practices/audio).\n\n\x0b\n\x03\x04\x04\x01\x12\x04\xbf\
    \x01\x08\x15\nj\n\x04\x04\x04\x04\0\x12\x06\xc2\x01\x02\xd2\x01\x03\x1aZ\
    \x20Audio\x20encoding\x20of\x20the\x20data\x20sent\x20in\x20the\x20audio\
    \x20message.\n\x20Audio\x20must\x20be\x20one-channel\x20(mono).\n\n\r\n\
    \x05\x04\x04\x04\0\x01\x12\x04\xc2\x01\x07\x0f\nY\n\x06\x04\x04\x04\0\
    \x02\0\x12\x04\xc4\x01\x04\x1d\x1aI\x20Not\x20specified.\x20Will\x20retu\
    rn\x20result\x20[google.rpc.Code.INVALID_ARGUMENT][].\n\n\x0f\n\x07\x04\
    \x04\x04\0\x02\0\x01\x12\x04\xc4\x01\x04\x18\n\x0f\n\x07\x04\x04\x04\0\
    \x02\0\x02\x12\x04\xc4\x01\x1b\x1c\n\x8d\x01\n\x06\x04\x04\x04\0\x02\x01\
    \x12\x04\xc8\x01\x04\x11\x1a}\x20Uncompressed\x2016-bit\x20signed\x20lit\
    tle-endian\x20samples\x20(Linear\x20PCM).\n\x20This\x20encoding\x20inclu\
    des\x20no\x20header,\x20only\x20the\x20raw\x20audio\x20bytes.\n\n\x0f\n\
    \x07\x04\x04\x04\0\x02\x01\x01\x12\x04\xc8\x01\x04\x0c\n\x0f\n\x07\x04\
    \x04\x04\0\x02\x01\x02\x12\x04\xc8\x01\x0f\x10\n\xa5\x03\n\x06\x04\x04\
    \x04\0\x02\x02\x12\x04\xd1\x01\x04\r\x1a\x94\x03\x20[`FLAC`](https://xip\
    h.org/flac/documentation.html)\x20(Free\x20Lossless\x20Audio\n\x20Codec)\
    \x20is\x20the\x20recommended\x20encoding\x20because\x20it\x20is\n\x20los\
    sless--therefore\x20recognition\x20is\x20not\x20compromised--and\n\x20re\
    quires\x20only\x20about\x20half\x20the\x20bandwidth\x20of\x20`LINEAR16`.\
    \x20This\x20encoding\n\x20includes\x20the\x20`FLAC`\x20stream\x20header\
    \x20followed\x20by\x20audio\x20data.\x20It\x20supports\n\x2016-bit\x20an\
    d\x2024-bit\x20samples,\x20however,\x20not\x20all\x20fields\x20in\x20`ST\
    REAMINFO`\x20are\n\x20supported.\n\n\x0f\n\x07\x04\x04\x04\0\x02\x02\x01\
    \x12\x04\xd1\x01\x04\x08\n\x0f\n\x07\x04\x04\x04\0\x02\x02\x02\x12\x04\
    \xd1\x01\x0b\x0c\nR\n\x04\x04\x04\x02\0\x12\x04\xd5\x01\x02\x18\x1aD\x20\
    *Required*\x20Encoding\x20of\x20audio\x20data\x20sent\x20in\x20all\x20`a\
    udio_in`\x20messages.\n\n\x0f\n\x05\x04\x04\x02\0\x04\x12\x06\xd5\x01\
    \x02\xd2\x01\x03\n\r\n\x05\x04\x04\x02\0\x06\x12\x04\xd5\x01\x02\n\n\r\n\
    \x05\x04\x04\x02\0\x01\x12\x04\xd5\x01\x0b\x13\n\r\n\x05\x04\x04\x02\0\
    \x03\x12\x04\xd5\x01\x16\x17\n\xcc\x02\n\x04\x04\x04\x02\x01\x12\x04\xdc\
    \x01\x02\x1e\x1a\xbd\x02\x20*Required*\x20Sample\x20rate\x20(in\x20Hertz\
    )\x20of\x20the\x20audio\x20data\x20sent\x20in\x20all\x20`audio_in`\n\x20\
    messages.\x20Valid\x20values\x20are\x20from\x2016000-24000,\x20but\x2016\
    000\x20is\x20optimal.\n\x20For\x20best\x20results,\x20set\x20the\x20samp\
    ling\x20rate\x20of\x20the\x20audio\x20source\x20to\x2016000\x20Hz.\n\x20\
    If\x20that's\x20not\x20possible,\x20use\x20the\x20native\x20sample\x20ra\
    te\x20of\x20the\x20audio\x20source\n\x20(instead\x20of\x20re-sampling).\
    \n\n\x0f\n\x05\x04\x04\x02\x01\x04\x12\x06\xdc\x01\x02\xd5\x01\x18\n\r\n\
    \x05\x04\x04\x02\x01\x05\x12\x04\xdc\x01\x02\x07\n\r\n\x05\x04\x04\x02\
    \x01\x01\x12\x04\xdc\x01\x08\x19\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\
    \xdc\x01\x1c\x1d\ni\n\x02\x04\x05\x12\x06\xe1\x01\0\x80\x02\x01\x1a[\x20\
    Specifies\x20the\x20desired\x20format\x20for\x20the\x20server\x20to\x20u\
    se\x20when\x20it\x20returns\n\x20`audio_out`\x20messages.\n\n\x0b\n\x03\
    \x04\x05\x01\x12\x04\xe1\x01\x08\x16\n\x9a\x01\n\x04\x04\x05\x04\0\x12\
    \x06\xe4\x01\x02\xf3\x01\x03\x1a\x89\x01\x20Audio\x20encoding\x20of\x20t\
    he\x20data\x20returned\x20in\x20the\x20audio\x20message.\x20All\x20encod\
    ings\x20are\n\x20raw\x20audio\x20bytes\x20with\x20no\x20header,\x20excep\
    t\x20as\x20indicated\x20below.\n\n\r\n\x05\x04\x05\x04\0\x01\x12\x04\xe4\
    \x01\x07\x0f\nY\n\x06\x04\x05\x04\0\x02\0\x12\x04\xe6\x01\x04\x1d\x1aI\
    \x20Not\x20specified.\x20Will\x20return\x20result\x20[google.rpc.Code.IN\
    VALID_ARGUMENT][].\n\n\x0f\n\x07\x04\x05\x04\0\x02\0\x01\x12\x04\xe6\x01\
    \x04\x18\n\x0f\n\x07\x04\x05\x04\0\x02\0\x02\x12\x04\xe6\x01\x1b\x1c\nP\
    \n\x06\x04\x05\x04\0\x02\x01\x12\x04\xe9\x01\x04\x11\x1a@\x20Uncompresse\
    d\x2016-bit\x20signed\x20little-endian\x20samples\x20(Linear\x20PCM).\n\
    \n\x0f\n\x07\x04\x05\x04\0\x02\x01\x01\x12\x04\xe9\x01\x04\x0c\n\x0f\n\
    \x07\x04\x05\x04\0\x02\x01\x02\x12\x04\xe9\x01\x0f\x10\nP\n\x06\x04\x05\
    \x04\0\x02\x02\x12\x04\xec\x01\x04\x0c\x1a@\x20MP3\x20audio\x20encoding.\
    \x20The\x20sample\x20rate\x20is\x20encoded\x20in\x20the\x20payload.\n\n\
    \x0f\n\x07\x04\x05\x04\0\x02\x02\x01\x12\x04\xec\x01\x04\x07\n\x0f\n\x07\
    \x04\x05\x04\0\x02\x02\x02\x12\x04\xec\x01\n\x0b\n\xb3\x02\n\x06\x04\x05\
    \x04\0\x02\x03\x12\x04\xf2\x01\x04\x14\x1a\xa2\x02\x20Opus-encoded\x20au\
    dio\x20wrapped\x20in\x20an\x20ogg\x20container.\x20The\x20result\x20will\
    \x20be\x20a\n\x20file\x20which\x20can\x20be\x20played\x20natively\x20on\
    \x20Android\x20and\x20in\x20some\x20browsers\x20(such\n\x20as\x20Chrome)\
    .\x20The\x20quality\x20of\x20the\x20encoding\x20is\x20considerably\x20hi\
    gher\x20than\x20MP3\n\x20while\x20using\x20the\x20same\x20bitrate.\x20Th\
    e\x20sample\x20rate\x20is\x20encoded\x20in\x20the\x20payload.\n\n\x0f\n\
    \x07\x04\x05\x04\0\x02\x03\x01\x12\x04\xf2\x01\x04\x0f\n\x0f\n\x07\x04\
    \x05\x04\0\x02\x03\x02\x12\x04\xf2\x01\x12\x13\nb\n\x04\x04\x05\x02\0\
    \x12\x04\xf7\x01\x02\x18\x1aT\x20*Required*\x20The\x20encoding\x20of\x20\
    audio\x20data\x20to\x20be\x20returned\x20in\x20all\x20`audio_out`\n\x20m\
    essages.\n\n\x0f\n\x05\x04\x05\x02\0\x04\x12\x06\xf7\x01\x02\xf3\x01\x03\
    \n\r\n\x05\x04\x05\x02\0\x06\x12\x04\xf7\x01\x02\n\n\r\n\x05\x04\x05\x02\
    \0\x01\x12\x04\xf7\x01\x0b\x13\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xf7\
    \x01\x16\x17\n\x87\x01\n\x04\x04\x05\x02\x01\x12\x04\xfb\x01\x02\x1e\x1a\
    y\x20*Required*\x20The\x20sample\x20rate\x20in\x20Hertz\x20of\x20the\x20\
    audio\x20data\x20returned\x20in\n\x20`audio_out`\x20messages.\x20Valid\
    \x20values\x20are:\x2016000-24000.\n\n\x0f\n\x05\x04\x05\x02\x01\x04\x12\
    \x06\xfb\x01\x02\xf7\x01\x18\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\xfb\
    \x01\x02\x07\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\xfb\x01\x08\x19\n\r\n\
    \x05\x04\x05\x02\x01\x03\x12\x04\xfb\x01\x1c\x1d\n\x89\x01\n\x04\x04\x05\
    \x02\x02\x12\x04\xff\x01\x02\x1e\x1a{\x20*Required*\x20Current\x20volume\
    \x20setting\x20of\x20the\x20device's\x20audio\x20output.\n\x20Valid\x20v\
    alues\x20are\x201\x20to\x20100\x20(corresponding\x20to\x201%\x20to\x2010\
    0%).\n\n\x0f\n\x05\x04\x05\x02\x02\x04\x12\x06\xff\x01\x02\xfb\x01\x1e\n\
    \r\n\x05\x04\x05\x02\x02\x05\x12\x04\xff\x01\x02\x07\n\r\n\x05\x04\x05\
    \x02\x02\x01\x12\x04\xff\x01\x08\x19\n\r\n\x05\x04\x05\x02\x02\x03\x12\
    \x04\xff\x01\x1c\x1d\nj\n\x02\x04\x06\x12\x06\x84\x02\0\x97\x02\x01\x1a\
    \\\x20Specifies\x20the\x20desired\x20format\x20for\x20the\x20server\x20t\
    o\x20use\x20when\x20it\x20returns\n\x20`screen_out`\x20response.\n\n\x0b\
    \n\x03\x04\x06\x01\x12\x04\x84\x02\x08\x17\nH\n\x04\x04\x06\x04\0\x12\
    \x06\x86\x02\x02\x93\x02\x03\x1a8\x20Possible\x20modes\x20for\x20visual\
    \x20screen-output\x20on\x20the\x20device.\n\n\r\n\x05\x04\x06\x04\0\x01\
    \x12\x04\x86\x02\x07\x11\nZ\n\x06\x04\x06\x04\0\x02\0\x12\x04\x89\x02\
    \x04\x20\x1aJ\x20No\x20video\x20mode\x20specified.\n\x20The\x20Assistant\
    \x20may\x20respond\x20as\x20if\x20in\x20`OFF`\x20mode.\n\n\x0f\n\x07\x04\
    \x06\x04\0\x02\0\x01\x12\x04\x89\x02\x04\x1b\n\x0f\n\x07\x04\x06\x04\0\
    \x02\0\x02\x12\x04\x89\x02\x1e\x1f\n\xae\x01\n\x06\x04\x06\x04\0\x02\x01\
    \x12\x04\x8e\x02\x04\x0c\x1a\x9d\x01\x20Screen\x20is\x20off\x20(or\x20ha\
    s\x20brightness\x20or\x20other\x20settings\x20set\x20so\x20low\x20it\x20\
    is\n\x20not\x20visible).\x20The\x20Assistant\x20will\x20typically\x20not\
    \x20return\x20a\x20screen\x20response\n\x20in\x20this\x20mode.\n\n\x0f\n\
    \x07\x04\x06\x04\0\x02\x01\x01\x12\x04\x8e\x02\x04\x07\n\x0f\n\x07\x04\
    \x06\x04\0\x02\x01\x02\x12\x04\x8e\x02\n\x0b\n^\n\x06\x04\x06\x04\0\x02\
    \x02\x12\x04\x92\x02\x04\x10\x1aN\x20The\x20Assistant\x20will\x20typical\
    ly\x20return\x20a\x20partial-screen\x20response\x20in\x20this\n\x20mode.\
    \n\n\x0f\n\x07\x04\x06\x04\0\x02\x02\x01\x12\x04\x92\x02\x04\x0b\n\x0f\n\
    \x07\x04\x06\x04\0\x02\x02\x02\x12\x04\x92\x02\x0e\x0f\nR\n\x04\x04\x06\
    \x02\0\x12\x04\x96\x02\x02\x1d\x1aD\x20Current\x20visual\x20screen-mode\
    \x20for\x20the\x20device\x20while\x20issuing\x20the\x20query.\n\n\x0f\n\
    \x05\x04\x06\x02\0\x04\x12\x06\x96\x02\x02\x93\x02\x03\n\r\n\x05\x04\x06\
    \x02\0\x06\x12\x04\x96\x02\x02\x0c\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\
    \x96\x02\r\x18\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\x96\x02\x1b\x1c\nD\n\
    \x02\x04\x07\x12\x06\x9a\x02\0\xb3\x02\x01\x1a6\x20Provides\x20informati\
    on\x20about\x20the\x20current\x20dialog\x20state.\n\n\x0b\n\x03\x04\x07\
    \x01\x12\x04\x9a\x02\x08\x15\n\xa2\x03\n\x04\x04\x07\x02\0\x12\x04\xa0\
    \x02\x02\x1f\x1a\x93\x03\x20*Required*\x20This\x20field\x20must\x20alway\
    s\x20be\x20set\x20to\x20the\n\x20[DialogStateOut.conversation_state][goo\
    gle.assistant.embedded.v1alpha2.DialogStateOut.conversation_state]\x20va\
    lue\x20that\x20was\x20returned\x20in\x20the\x20prior\n\x20`Assist`\x20RP\
    C.\x20It\x20should\x20only\x20be\x20omitted\x20(field\x20not\x20set)\x20\
    if\x20there\x20was\x20no\n\x20prior\x20`Assist`\x20RPC\x20because\x20thi\
    s\x20is\x20the\x20first\x20`Assist`\x20RPC\x20made\x20by\x20this\n\x20de\
    vice\x20after\x20it\x20was\x20first\x20setup\x20and/or\x20a\x20factory-d\
    efault\x20reset.\n\n\x0f\n\x05\x04\x07\x02\0\x04\x12\x06\xa0\x02\x02\x9a\
    \x02\x17\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\xa0\x02\x02\x07\n\r\n\x05\
    \x04\x07\x02\0\x01\x12\x04\xa0\x02\x08\x1a\n\r\n\x05\x04\x07\x02\0\x03\
    \x12\x04\xa0\x02\x1d\x1e\n\xf4\x03\n\x04\x04\x07\x02\x01\x12\x04\xa9\x02\
    \x02\x1b\x1a\xe5\x03\x20*Required*\x20Language\x20of\x20the\x20request\
    \x20in\n\x20[IETF\x20BCP\x2047\x20syntax](https://tools.ietf.org/html/bc\
    p47)\x20(for\x20example,\n\x20\"en-US\").\x20See\x20[Language\x20Support\
    ](https://developers.google.com/assistant/sdk/reference/rpc/languages)\n\
    \x20for\x20more\x20information.\x20If\x20you\x20have\x20selected\x20a\
    \x20language\x20for\x20this\x20`device_id`\n\x20using\x20the\x20[Setting\
    s](https://developers.google.com/assistant/sdk/reference/assistant-app/a\
    ssistant-settings)\n\x20menu\x20in\x20your\x20phone's\x20Google\x20Assis\
    tant\x20app,\x20that\x20selection\x20will\x20override\n\x20this\x20value\
    .\n\n\x0f\n\x05\x04\x07\x02\x01\x04\x12\x06\xa9\x02\x02\xa0\x02\x1f\n\r\
    \n\x05\x04\x07\x02\x01\x05\x12\x04\xa9\x02\x02\x08\n\r\n\x05\x04\x07\x02\
    \x01\x01\x12\x04\xa9\x02\t\x16\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\xa9\
    \x02\x19\x1a\nM\n\x04\x04\x07\x02\x02\x12\x04\xac\x02\x02%\x1a?\x20*Opti\
    onal*\x20Location\x20of\x20the\x20device\x20where\x20the\x20query\x20ori\
    ginated.\n\n\x0f\n\x05\x04\x07\x02\x02\x04\x12\x06\xac\x02\x02\xa9\x02\
    \x1b\n\r\n\x05\x04\x07\x02\x02\x06\x12\x04\xac\x02\x02\x10\n\r\n\x05\x04\
    \x07\x02\x02\x01\x12\x04\xac\x02\x11\x20\n\r\n\x05\x04\x07\x02\x02\x03\
    \x12\x04\xac\x02#$\n\xa6\x02\n\x04\x04\x07\x02\x03\x12\x04\xb2\x02\x02\
    \x1f\x1a\x97\x02\x20*Optional*\x20If\x20true,\x20the\x20server\x20will\
    \x20treat\x20the\x20request\x20as\x20a\x20new\x20conversation\n\x20and\
    \x20not\x20use\x20state\x20from\x20the\x20prior\x20request.\x20Set\x20th\
    is\x20field\x20to\x20true\x20when\x20the\n\x20conversation\x20should\x20\
    be\x20restarted,\x20such\x20as\x20after\x20a\x20device\x20reboot,\x20or\
    \x20after\x20a\n\x20significant\x20lapse\x20of\x20time\x20since\x20the\
    \x20prior\x20query.\n\n\x0f\n\x05\x04\x07\x02\x03\x04\x12\x06\xb2\x02\
    \x02\xac\x02%\n\r\n\x05\x04\x07\x02\x03\x05\x12\x04\xb2\x02\x02\x06\n\r\
    \n\x05\x04\x07\x02\x03\x01\x12\x04\xb2\x02\x07\x1a\n\r\n\x05\x04\x07\x02\
    \x03\x03\x12\x04\xb2\x02\x1d\x1e\n\xea\x03\n\x02\x04\x08\x12\x06\xbf\x02\
    \0\xcd\x02\x01\x1a\xdb\x03\x20*Required*\x20Fields\x20that\x20identify\
    \x20the\x20device\x20to\x20the\x20Assistant.\n\n\x20See\x20also:\n\n\x20\
    *\x20\x20\x20[Register\x20a\x20Device\x20-\x20REST\n\x20API](https://dev\
    elopers.google.com/assistant/sdk/reference/device-registration/register-\
    device-manual)\n\x20*\x20\x20\x20[Device\x20Model\x20and\x20Instance\n\
    \x20Schemas](https://developers.google.com/assistant/sdk/reference/devic\
    e-registration/model-and-instance-schemas)\n\x20*\x20\x20\x20[Device\n\
    \x20Proto](https://developers.google.com/assistant/sdk/reference/rpc/goo\
    gle.assistant.devices.v1alpha2#device)\n\n\x0b\n\x03\x04\x08\x01\x12\x04\
    \xbf\x02\x08\x14\n\xc7\x03\n\x04\x04\x08\x02\0\x12\x04\xc7\x02\x02\x17\
    \x1a\xb8\x03\x20*Required*\x20Unique\x20identifier\x20for\x20the\x20devi\
    ce.\x20The\x20id\x20length\x20must\x20be\x20128\n\x20characters\x20or\
    \x20less.\x20Example:\x20DBCDW098234.\x20This\x20MUST\x20match\x20the\
    \x20device_id\n\x20returned\x20from\x20device\x20registration.\x20This\
    \x20device_id\x20is\x20used\x20to\x20match\x20against\n\x20the\x20user's\
    \x20registered\x20devices\x20to\x20lookup\x20the\x20supported\x20traits\
    \x20and\n\x20capabilities\x20of\x20this\x20device.\x20This\x20informatio\
    n\x20should\x20not\x20change\x20across\n\x20device\x20reboots.\x20Howeve\
    r,\x20it\x20should\x20not\x20be\x20saved\x20across\n\x20factory-default\
    \x20resets.\n\n\x0f\n\x05\x04\x08\x02\0\x04\x12\x06\xc7\x02\x02\xbf\x02\
    \x16\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\xc7\x02\x02\x08\n\r\n\x05\x04\
    \x08\x02\0\x01\x12\x04\xc7\x02\t\x12\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\
    \xc7\x02\x15\x16\n\xb8\x01\n\x04\x04\x08\x02\x01\x12\x04\xcc\x02\x02\x1d\
    \x1a\xa9\x01\x20*Required*\x20Unique\x20identifier\x20for\x20the\x20devi\
    ce\x20model.\x20The\x20combination\x20of\n\x20device_model_id\x20and\x20\
    device_id\x20must\x20have\x20been\x20previously\x20associated\x20through\
    \n\x20device\x20registration.\n\n\x0f\n\x05\x04\x08\x02\x01\x04\x12\x06\
    \xcc\x02\x02\xc7\x02\x17\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\xcc\x02\
    \x02\x08\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xcc\x02\t\x18\n\r\n\x05\
    \x04\x08\x02\x01\x03\x12\x04\xcc\x02\x1b\x1c\n\xa3\x01\n\x02\x04\t\x12\
    \x06\xd1\x02\0\xd6\x02\x01\x1a\x94\x01\x20The\x20audio\x20containing\x20\
    the\x20Assistant's\x20response\x20to\x20the\x20query.\x20Sequential\x20c\
    hunks\n\x20of\x20audio\x20data\x20are\x20received\x20in\x20sequential\
    \x20`AssistResponse`\x20messages.\n\n\x0b\n\x03\x04\t\x01\x12\x04\xd1\
    \x02\x08\x10\n\xb7\x01\n\x04\x04\t\x02\0\x12\x04\xd5\x02\x02\x17\x1a\xa8\
    \x01\x20*Output-only*\x20The\x20audio\x20data\x20containing\x20the\x20As\
    sistant's\x20response\x20to\x20the\n\x20query.\x20Sequential\x20chunks\
    \x20of\x20audio\x20data\x20are\x20received\x20in\x20sequential\n\x20`Ass\
    istResponse`\x20messages.\n\n\x0f\n\x05\x04\t\x02\0\x04\x12\x06\xd5\x02\
    \x02\xd1\x02\x12\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xd5\x02\x02\x07\n\r\n\
    \x05\x04\t\x02\0\x01\x12\x04\xd5\x02\x08\x12\n\r\n\x05\x04\t\x02\0\x03\
    \x12\x04\xd5\x02\x15\x16\na\n\x02\x04\n\x12\x06\xda\x02\0\xed\x02\x01\
    \x1aS\x20The\x20Assistant's\x20visual\x20output\x20response\x20to\x20que\
    ry.\x20Enabled\x20by\n\x20`screen_out_config`.\n\n\x0b\n\x03\x04\n\x01\
    \x12\x04\xda\x02\x08\x11\n6\n\x04\x04\n\x04\0\x12\x06\xdc\x02\x02\xe5\
    \x02\x03\x1a&\x20Possible\x20formats\x20of\x20the\x20screen\x20data.\n\n\
    \r\n\x05\x04\n\x04\0\x01\x12\x04\xdc\x02\x07\r\n&\n\x06\x04\n\x04\0\x02\
    \0\x12\x04\xde\x02\x04\x1b\x1a\x16\x20No\x20format\x20specified.\n\n\x0f\
    \n\x07\x04\n\x04\0\x02\0\x01\x12\x04\xde\x02\x04\x16\n\x0f\n\x07\x04\n\
    \x04\0\x02\0\x02\x12\x04\xde\x02\x19\x1a\n\x87\x02\n\x06\x04\n\x04\0\x02\
    \x01\x12\x04\xe4\x02\x04\r\x1a\xf6\x01\x20Data\x20will\x20contain\x20a\
    \x20fully-formed\x20HTML5\x20layout\x20encoded\x20in\x20UTF-8,\x20e.g.\n\
    \x20`<html><body><div>...</div></body></html>`.\x20It\x20is\x20intended\
    \x20to\x20be\x20rendered\n\x20along\x20with\x20the\x20audio\x20response.\
    \x20Note\x20that\x20HTML5\x20doctype\x20should\x20be\x20included\n\x20in\
    \x20the\x20actual\x20HTML\x20data.\n\n\x0f\n\x07\x04\n\x04\0\x02\x01\x01\
    \x12\x04\xe4\x02\x04\x08\n\x0f\n\x07\x04\n\x04\0\x02\x01\x02\x12\x04\xe4\
    \x02\x0b\x0c\nE\n\x04\x04\n\x02\0\x12\x04\xe8\x02\x02\x14\x1a7\x20*Outpu\
    t-only*\x20The\x20format\x20of\x20the\x20provided\x20screen\x20data.\n\n\
    \x0f\n\x05\x04\n\x02\0\x04\x12\x06\xe8\x02\x02\xe5\x02\x03\n\r\n\x05\x04\
    \n\x02\0\x06\x12\x04\xe8\x02\x02\x08\n\r\n\x05\x04\n\x02\0\x01\x12\x04\
    \xe8\x02\t\x0f\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xe8\x02\x12\x13\nh\n\
    \x04\x04\n\x02\x01\x12\x04\xec\x02\x02\x11\x1aZ\x20*Output-only*\x20The\
    \x20raw\x20screen\x20data\x20to\x20be\x20displayed\x20as\x20the\x20resul\
    t\x20of\x20the\n\x20Assistant\x20query.\n\n\x0f\n\x05\x04\n\x02\x01\x04\
    \x12\x06\xec\x02\x02\xe8\x02\x14\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\xec\
    \x02\x02\x07\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xec\x02\x08\x0c\n\r\n\
    \x05\x04\n\x02\x01\x03\x12\x04\xec\x02\x0f\x10\n\x81\x02\n\x02\x04\x0b\
    \x12\x06\xf3\x02\0\xf9\x02\x01\x1a\xf2\x01\x20The\x20response\x20returne\
    d\x20to\x20the\x20device\x20if\x20the\x20user\x20has\x20triggered\x20a\
    \x20Device\n\x20Action.\x20For\x20example,\x20a\x20device\x20which\x20su\
    pports\x20the\x20query\x20*Turn\x20on\x20the\x20light*\n\x20would\x20rec\
    eive\x20a\x20`DeviceAction`\x20with\x20a\x20JSON\x20payload\x20containin\
    g\x20the\x20semantics\n\x20of\x20the\x20request.\n\n\x0b\n\x03\x04\x0b\
    \x01\x12\x04\xf3\x02\x08\x14\n\x82\x02\n\x04\x04\x0b\x02\0\x12\x04\xf8\
    \x02\x02!\x1a\xf3\x01\x20JSON\x20containing\x20the\x20device\x20command\
    \x20response\x20generated\x20from\x20the\x20triggered\n\x20Device\x20Act\
    ion\x20grammar.\x20The\x20format\x20is\x20given\x20by\x20the\n\x20`actio\
    n.devices.EXECUTE`\x20intent\x20for\x20a\x20given\n\x20[trait](https://d\
    evelopers.google.com/assistant/sdk/reference/traits/).\n\n\x0f\n\x05\x04\
    \x0b\x02\0\x04\x12\x06\xf8\x02\x02\xf3\x02\x16\n\r\n\x05\x04\x0b\x02\0\
    \x05\x12\x04\xf8\x02\x02\x08\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xf8\x02\
    \t\x1c\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xf8\x02\x1f\x20\n\x9b\x01\n\
    \x02\x04\x0c\x12\x06\xfd\x02\0\x86\x03\x01\x1a\x8c\x01\x20The\x20estimat\
    ed\x20transcription\x20of\x20a\x20phrase\x20the\x20user\x20has\x20spoken\
    .\x20This\x20could\x20be\n\x20a\x20single\x20segment\x20or\x20the\x20ful\
    l\x20guess\x20of\x20the\x20user's\x20spoken\x20query.\n\n\x0b\n\x03\x04\
    \x0c\x01\x12\x04\xfd\x02\x08\x1f\nY\n\x04\x04\x0c\x02\0\x12\x04\xff\x02\
    \x02\x18\x1aK\x20*Output-only*\x20Transcript\x20text\x20representing\x20\
    the\x20words\x20that\x20the\x20user\x20spoke.\n\n\x0f\n\x05\x04\x0c\x02\
    \0\x04\x12\x06\xff\x02\x02\xfd\x02!\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\
    \xff\x02\x02\x08\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xff\x02\t\x13\n\r\n\
    \x05\x04\x0c\x02\0\x03\x12\x04\xff\x02\x16\x17\n\x9c\x02\n\x04\x04\x0c\
    \x02\x01\x12\x04\x85\x03\x02\x16\x1a\x8d\x02\x20*Output-only*\x20An\x20e\
    stimate\x20of\x20the\x20likelihood\x20that\x20the\x20Assistant\x20will\
    \x20not\n\x20change\x20its\x20guess\x20about\x20this\x20result.\x20Value\
    s\x20range\x20from\x200.0\x20(completely\n\x20unstable)\x20to\x201.0\x20\
    (completely\x20stable\x20and\x20final).\x20The\x20default\x20of\x200.0\
    \x20is\x20a\n\x20sentinel\x20value\x20indicating\x20`stability`\x20was\
    \x20not\x20set.\n\n\x0f\n\x05\x04\x0c\x02\x01\x04\x12\x06\x85\x03\x02\
    \xff\x02\x18\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\x85\x03\x02\x07\n\r\n\
    \x05\x04\x0c\x02\x01\x01\x12\x04\x85\x03\x08\x11\n\r\n\x05\x04\x0c\x02\
    \x01\x03\x12\x04\x85\x03\x14\x15\nn\n\x02\x04\r\x12\x06\x8a\x03\0\xb6\
    \x03\x01\x1a`\x20The\x20dialog\x20state\x20resulting\x20from\x20the\x20u\
    ser's\x20query.\x20Multiple\x20of\x20these\x20messages\n\x20may\x20be\
    \x20received.\n\n\x0b\n\x03\x04\r\x01\x12\x04\x8a\x03\x08\x16\nS\n\x04\
    \x04\r\x04\0\x12\x06\x8c\x03\x02\x98\x03\x03\x1aC\x20Possible\x20states\
    \x20of\x20the\x20microphone\x20after\x20a\x20`Assist`\x20RPC\x20complete\
    s.\n\n\r\n\x05\x04\r\x04\0\x01\x12\x04\x8c\x03\x07\x15\n$\n\x06\x04\r\
    \x04\0\x02\0\x12\x04\x8e\x03\x04$\x1a\x14\x20No\x20mode\x20specified.\n\
    \n\x0f\n\x07\x04\r\x04\0\x02\0\x01\x12\x04\x8e\x03\x04\x1f\n\x0f\n\x07\
    \x04\r\x04\0\x02\0\x02\x12\x04\x8e\x03\"#\n\x95\x01\n\x06\x04\r\x04\0\
    \x02\x01\x12\x04\x92\x03\x04\x19\x1a\x84\x01\x20The\x20service\x20is\x20\
    not\x20expecting\x20a\x20follow-on\x20question\x20from\x20the\x20user.\n\
    \x20The\x20microphone\x20should\x20remain\x20off\x20until\x20the\x20user\
    \x20re-activates\x20it.\n\n\x0f\n\x07\x04\r\x04\0\x02\x01\x01\x12\x04\
    \x92\x03\x04\x14\n\x0f\n\x07\x04\r\x04\0\x02\x01\x02\x12\x04\x92\x03\x17\
    \x18\n\xd8\x01\n\x06\x04\r\x04\0\x02\x02\x12\x04\x97\x03\x04\x19\x1a\xc7\
    \x01\x20The\x20service\x20is\x20expecting\x20a\x20follow-on\x20question\
    \x20from\x20the\x20user.\x20The\n\x20microphone\x20should\x20be\x20re-op\
    ened\x20when\x20the\x20`AudioOut`\x20playback\x20completes\n\x20(by\x20s\
    tarting\x20a\x20new\x20`Assist`\x20RPC\x20call\x20to\x20send\x20the\x20n\
    ew\x20audio).\n\n\x0f\n\x07\x04\r\x04\0\x02\x02\x01\x12\x04\x97\x03\x04\
    \x14\n\x0f\n\x07\x04\r\x04\0\x02\x02\x02\x12\x04\x97\x03\x17\x18\n\xe8\
    \x01\n\x04\x04\r\x02\0\x12\x04\x9d\x03\x02'\x1a\xd9\x01\x20*Output-only*\
    \x20Supplemental\x20display\x20text\x20from\x20the\x20Assistant.\x20This\
    \x20could\x20be\n\x20the\x20same\x20as\x20the\x20speech\x20spoken\x20in\
    \x20`AssistResponse.audio_out`\x20or\x20it\x20could\n\x20be\x20some\x20a\
    dditional\x20information\x20which\x20aids\x20the\x20user's\x20understand\
    ing.\n\n\x0f\n\x05\x04\r\x02\0\x04\x12\x06\x9d\x03\x02\x98\x03\x03\n\r\n\
    \x05\x04\r\x02\0\x05\x12\x04\x9d\x03\x02\x08\n\r\n\x05\x04\r\x02\0\x01\
    \x12\x04\x9d\x03\t\"\n\r\n\x05\x04\r\x02\0\x03\x12\x04\x9d\x03%&\n\xc8\
    \x03\n\x04\x04\r\x02\x01\x12\x04\xa6\x03\x02\x1f\x1a\xb9\x03\x20*Output-\
    only*\x20State\x20information\x20for\x20the\x20subsequent\x20`Assist`\
    \x20RPC.\x20This\n\x20value\x20should\x20be\x20saved\x20in\x20the\x20cli\
    ent\x20and\x20returned\x20in\x20the\n\x20[`DialogStateIn.conversation_st\
    ate`](#dialogstatein)\x20field\x20with\x20the\x20next\n\x20`Assist`\x20R\
    PC.\x20(The\x20client\x20does\x20not\x20need\x20to\x20interpret\x20or\
    \x20otherwise\x20use\x20this\n\x20value.)\x20This\x20information\x20shou\
    ld\x20be\x20saved\x20across\x20device\x20reboots.\x20However,\n\x20this\
    \x20value\x20should\x20be\x20cleared\x20(not\x20saved\x20in\x20the\x20cl\
    ient)\x20during\x20a\n\x20factory-default\x20reset.\n\n\x0f\n\x05\x04\r\
    \x02\x01\x04\x12\x06\xa6\x03\x02\x9d\x03'\n\r\n\x05\x04\r\x02\x01\x05\
    \x12\x04\xa6\x03\x02\x07\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xa6\x03\x08\
    \x1a\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xa6\x03\x1d\x1e\ni\n\x04\x04\r\
    \x02\x02\x12\x04\xaa\x03\x02%\x1a[\x20*Output-only*\x20Specifies\x20the\
    \x20mode\x20of\x20the\x20microphone\x20after\x20this\x20`Assist`\n\x20RP\
    C\x20is\x20processed.\n\n\x0f\n\x05\x04\r\x02\x02\x04\x12\x06\xaa\x03\
    \x02\xa6\x03\x1f\n\r\n\x05\x04\r\x02\x02\x06\x12\x04\xaa\x03\x02\x10\n\r\
    \n\x05\x04\r\x02\x02\x01\x12\x04\xaa\x03\x11\x20\n\r\n\x05\x04\r\x02\x02\
    \x03\x12\x04\xaa\x03#$\n\x98\x05\n\x04\x04\r\x02\x03\x12\x04\xb5\x03\x02\
    \x1e\x1a\x89\x05\x20*Output-only*\x20Updated\x20volume\x20level.\x20The\
    \x20value\x20will\x20be\x200\x20or\x20omitted\n\x20(indicating\x20no\x20\
    change)\x20unless\x20a\x20voice\x20command\x20such\x20as\x20*Increase\
    \x20the\x20volume*\n\x20or\x20*Set\x20volume\x20level\x204*\x20was\x20re\
    cognized,\x20in\x20which\x20case\x20the\x20value\x20will\x20be\n\x20betw\
    een\x201\x20and\x20100\x20(corresponding\x20to\x20the\x20new\x20volume\
    \x20level\x20of\x201%\x20to\x20100%).\n\x20Typically,\x20a\x20client\x20\
    should\x20use\x20this\x20volume\x20level\x20when\x20playing\x20the\n\x20\
    `audio_out`\x20data,\x20and\x20retain\x20this\x20value\x20as\x20the\x20c\
    urrent\x20volume\x20level\x20and\n\x20supply\x20it\x20in\x20the\x20`Audi\
    oOutConfig`\x20of\x20the\x20next\x20`AssistRequest`.\x20(Some\n\x20clien\
    ts\x20may\x20also\x20implement\x20other\x20ways\x20to\x20allow\x20the\
    \x20current\x20volume\x20level\x20to\n\x20be\x20changed,\x20for\x20examp\
    le,\x20by\x20providing\x20a\x20knob\x20that\x20the\x20user\x20can\x20tur\
    n.)\n\n\x0f\n\x05\x04\r\x02\x03\x04\x12\x06\xb5\x03\x02\xaa\x03%\n\r\n\
    \x05\x04\r\x02\x03\x05\x12\x04\xb5\x03\x02\x07\n\r\n\x05\x04\r\x02\x03\
    \x01\x12\x04\xb5\x03\x08\x19\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\xb5\x03\
    \x1c\x1d\n=\n\x02\x04\x0e\x12\x06\xb9\x03\0\xbe\x03\x01\x1a/\x20Debuggin\
    g\x20parameters\x20for\x20the\x20current\x20request.\n\n\x0b\n\x03\x04\
    \x0e\x01\x12\x04\xb9\x03\x08\x13\n\xdb\x01\n\x04\x04\x0e\x02\0\x12\x04\
    \xbd\x03\x02\x1d\x1a\xcc\x01\x20When\x20this\x20field\x20is\x20set\x20to\
    \x20true,\x20the\x20`debug_info`\x20field\x20in\x20`AssistResponse`\n\
    \x20may\x20be\x20populated.\x20However\x20it\x20will\x20significantly\
    \x20increase\x20latency\x20of\n\x20responses.\x20Do\x20not\x20set\x20thi\
    s\x20field\x20true\x20in\x20production\x20code.\n\n\x0f\n\x05\x04\x0e\
    \x02\0\x04\x12\x06\xbd\x03\x02\xb9\x03\x15\n\r\n\x05\x04\x0e\x02\0\x05\
    \x12\x04\xbd\x03\x02\x06\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xbd\x03\x07\
    \x18\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xbd\x03\x1b\x1c\n\xae\x03\n\x02\
    \x04\x0f\x12\x06\xc8\x03\0\xcd\x03\x01\x1a\x9f\x03\x20There\x20are\x20th\
    ree\x20sources\x20of\x20locations.\x20They\x20are\x20used\x20with\x20thi\
    s\x20precedence:\n\n\x201.\x20This\x20`DeviceLocation`,\x20which\x20is\
    \x20primarily\x20used\x20for\x20mobile\x20devices\x20with\n\x20\x20\x20\
    \x20GPS\x20.\n\x202.\x20Location\x20specified\x20by\x20the\x20user\x20du\
    ring\x20device\x20setup;\x20this\x20is\x20per-user,\x20per\n\x20\x20\x20\
    \x20device.\x20This\x20location\x20is\x20used\x20if\x20`DeviceLocation`\
    \x20is\x20not\x20specified.\n\x203.\x20Inferred\x20location\x20based\x20\
    on\x20IP\x20address.\x20This\x20is\x20used\x20only\x20if\x20neither\x20o\
    f\x20the\n\x20\x20\x20\x20above\x20are\x20specified.\n\n\x0b\n\x03\x04\
    \x0f\x01\x12\x04\xc8\x03\x08\x16\n\x0e\n\x04\x04\x0f\x08\0\x12\x06\xc9\
    \x03\x02\xcc\x03\x03\n\r\n\x05\x04\x0f\x08\0\x01\x12\x04\xc9\x03\x08\x0c\
    \n1\n\x04\x04\x0f\x02\0\x12\x04\xcb\x03\x04'\x1a#\x20Latitude\x20and\x20\
    longitude\x20of\x20device.\n\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\xcb\x03\
    \x04\x16\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xcb\x03\x17\"\n\r\n\x05\x04\
    \x0f\x02\0\x03\x12\x04\xcb\x03%&b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
